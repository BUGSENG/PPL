/* Sorting objects for which copies cost more than swaps.
   Copyright (C) 2001-2004 Roberto Bagnara <bagnara@cs.unipr.it>

This file is part of the Parma Polyhedra Library (PPL).

The PPL is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at your
option) any later version.

The PPL is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
USA.

For the most up-to-date information see the Parma Polyhedra Library
site: http://www.cs.unipr.it/ppl/ . */

#ifndef PPL_swapping_sort_icc
#define PPL_swapping_sort_icc 1

#include <iterator>
#include <algorithm>

namespace {
/*
  This sorting algorithm avoids (almost all) copies of objects
  by performing more iter_swap's: it is meant to be used when
  object copying costs much more than object swapping.

  Moreover, the algorithm always uses std:iter_swap() instead of
  std::swap() so as to behave as expected when instantiated on
  Linear_System::With_Saturation_Matrix_iterator. Namely, using a sorting
  routine that either copies objects or directly swaps them
  (i.e., without calling std::iter_swap) would not be correct
  when using Linear_System::With_Saturation_Matrix_iterator.
*/

template <typename ValueType, typename Compare>
inline const ValueType&
median(const ValueType& x, const ValueType& y, const ValueType& z,
       Compare comp) {
  return comp(x, y)
    ? (comp(y, z) ? y : (comp(x, z) ? z : x))
    : (comp(x, z) ? x : (comp(y, z) ? z : y)); 
}

template <typename Iter, typename ValueType, typename Compare>
Iter
swapping_partition(Iter first, Iter last, const ValueType& pivot,
		   Compare comp) {
  while (true) {
    while (comp(*first, pivot))
      ++first;
    --last;
    while (comp(pivot, *last))
      --last;
    if (!(first < last))
      return first;
    std::iter_swap(first, last);
    ++first;
  }
}

template <typename Iter, typename Compare>
void
swapping_insertion_sort(Iter first, Iter last, Compare comp) {
  if (first == last)
    return;
  for (Iter i = first + 1; i != last; ++i)
    if (comp(*i, *first)) {
      Iter next = i + 1;
      while (i != first)
	std::iter_swap(--i, --next);
    }
    else {
      Iter previous = i - 1;
      while (comp(*i, *previous)) {
	std::iter_swap(i, previous);
	i = previous;
	--previous;
      }
    }
}

template <typename Iter, typename Compare>
void
swapping_quicksort_loop(Iter first, Iter last, Compare comp) {
  const typename std::iterator_traits<Iter>::difference_type threshold = 16;
  while (last - first > threshold) {
    // The construction of this temporary object is
    // required for the correctness of the algorithm.
    typename std::iterator_traits<Iter>::value_type
      pivot = median(*first,
		     *(first + (last - first) / 2),
		     *(last - 1),
		     comp);
    Iter cut = swapping_partition(first, last, pivot, comp);
    swapping_quicksort_loop(cut, last, comp);
    last = cut;
  }
}

template <typename Iter, typename Compare>
inline void
swapping_sort(Iter first, Iter last, Compare comp) {
  if (first != last) {
    swapping_quicksort_loop(first, last, comp);
    swapping_insertion_sort(first, last, comp);
  }
}

template <typename Iter>
Iter
swapping_unique(Iter first, Iter last) {
  Iter current = std::adjacent_find(first, last);
  if (current == last)
    return last;
  Iter next = current;
  ++next;
  while (++next != last)
    if (*current != *next)
      std::iter_swap(++current, next);
  return ++current;
}

} // anonymous namespace

#endif // !defined(PPL_swapping_sort_icc)
