/* GenSys class implementation (non-inline functions).
   Copyright (C) 2001, 2002 Roberto Bagnara <bagnara@cs.unipr.it>

This file is part of the Parma Polyhedra Library (PPL).

The PPL is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at your
option) any later version.

The PPL is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
USA.

For the most up-to-date information see the Parma Polyhedra Library
site: http://www.cs.unipr.it/ppl/ . */

#include <config.h>

#include "GenSys.defs.hh"

#include "Constraint.defs.hh"
#include <cassert>
#include <string>
#include <vector>
#include <iostream>
#include <stdexcept>

namespace PPL = Parma_Polyhedra_Library;

size_t
PPL::GenSys::num_lines() const {
  size_t n = 0;
  // If the Matrix happens to be sorted, take advantage of the fact
  // that lines are at the top of the system.
  if (is_sorted()) {
    size_t nrows = num_rows();
    for (size_t i = 0; i < nrows && (*this)[i].is_line(); ++i)
      ++n;
  }
  else
    for (size_t i = num_rows(); i-- > 0 ; )
      if ((*this)[i].is_line())
	++n;
  return n;
}

size_t
PPL::GenSys::num_rays() const {
  size_t n = 0;
  // If the Matrix happens to be sorted, take advantage of the fact
  // that rays and vertices are at the bottom of the system and
  // rays have the inhomogeneous term equal to zero.
  if (is_sorted()) {
    const GenSys& x = *this;
    for (size_t i = num_rows(); i != 0 && x[--i].is_ray_or_vertex(); )
      if (x[i][0] == 0)
	++n;
  }
  else
    for (size_t i = num_rows(); i-- > 0 ; ) {
      const Generator& g = (*this)[i];
      if (g.is_ray_or_vertex() && g[0] == 0)
	++n;
    }
  return n;
}

/*!
  Returns the relation holding between the set of points generated
  by \p *this and the constraint \p c.

  Note that if \p c is an equality, then the value <CODE>IS_INCLUDED</CODE>
  can not be returned.
*/
PPL::Poly_Con_Relation
PPL::GenSys::relation_with(const Constraint& c) const {
  // Note: this method is not public and it is the responsibility
  // of the caller to actually test for dimension compatibility.
  // We simply _assert_ it.
  assert(space_dimension() >= c.space_dimension());
  // Number of generators: the case of an empty polyhedron
  // has already been filtered out by the caller.
  size_t n_rows = num_rows();
  assert(n_rows > 0);
  const GenSys& gen_sys = *this;

  // `res' will keep the relation holding between the generators
  // we have seen so far and the constraint `c'.
  Poly_Con_Relation res = Poly_Con_Relation::saturates();

  if (c.is_equality()) {
    // The following integer variable will hold the scalar product sign
    // of either the first vertex or the first non-saturating ray we find.
    // If it is equal to 2, then it means that we haven't found such
    // a generator yet.
    int first_vertex_or_nonsaturating_ray_sign = 2;
    for (size_t i = n_rows; i-- > 0; ) {
      const Generator& g = gen_sys[i];
      int sp_sign = sgn(c * g);
      if (g.is_line()) {
	if (sp_sign != 0)
	  // If a line does not saturate `c', then there is a strict
	  // intersection between the points satisfying `c' and the points
	  // generated by `gen_sys'.
	  return Poly_Con_Relation::strictly_intersects();
      }
      else {
	// The generator `g' is a vertex or a ray.
	if (g[0] == 0) {
	  // `g' is a ray: if it saturates `c' there is nothing to do.
	  if (sp_sign != 0) {
	    if (first_vertex_or_nonsaturating_ray_sign == 2) {
	      // It is the first time that we have a non-saturating ray
	      // and we have not found any vertex yet.
	      first_vertex_or_nonsaturating_ray_sign = sp_sign;
	      res = Poly_Con_Relation::is_disjoint();
	    }
	    else {
	      // We already found a vertex or a non-saturating ray.
	      if (sp_sign != first_vertex_or_nonsaturating_ray_sign)
		return Poly_Con_Relation::strictly_intersects();
	    }
	  }
	}
	else {
	  // The generator `g' is a vertex.
	  if (first_vertex_or_nonsaturating_ray_sign == 2) {
	    // It is the first time that we find a vertex and
	    // we have not found a non-saturating ray yet.
	    first_vertex_or_nonsaturating_ray_sign = sp_sign;
	    if (sp_sign != 0)
	      res = Poly_Con_Relation::is_disjoint();
	  }
	  else{
	    // We already found a vertex or a non-saturating ray.
	    if (sp_sign != first_vertex_or_nonsaturating_ray_sign)
	      return Poly_Con_Relation::strictly_intersects();
	  }
	}
      }
    }
    // We have seen all generators.
    return res;
  }
  else {
    // Here, the constraint `c' is an inequality.
    // The following boolean variable will be set to `false'
    // as soon as either we find (any) vertex or we find a
    // non-saturating ray.
    bool first_vertex_or_nonsaturating_ray = true;
    for (size_t i = n_rows; i-- > 0; ) {
      const Generator& g = gen_sys[i];
      int sp_sign = sgn(c * g);
      if (g.is_line()) {
	if (sp_sign != 0)
	  // If a line does not saturate `c', then there is a strict
	  // intersection between the points satisfying `c' and the points
	  // generated by `gen_sys'.
	  return Poly_Con_Relation::strictly_intersects();
      }
      else {
	// The generator `g' is a vertex or a ray.
	if (g[0] == 0) {
	  // `g' is a ray: if it saturates `c' there is nothing to do.
	  if (sp_sign != 0) {
	    if (first_vertex_or_nonsaturating_ray) {
	      // It is the first time that we have a non-saturating ray
	      // and we have not found any vertex yet.
	      first_vertex_or_nonsaturating_ray = false;
	      res = (sp_sign > 0) ? Poly_Con_Relation::is_included() : Poly_Con_Relation::is_disjoint();
	    }
	    else {
	      // We already found a vertex or a non-saturating ray.
	      if ((sp_sign > 0 && res == Poly_Con_Relation::is_disjoint())
		  || (sp_sign < 0 && res != Poly_Con_Relation::is_disjoint()))
		// We have a strict intersection if either:
		// - `g' satisfies `c' but none of the generators seen
		//    so far are included in `c'; or
		// - `g' does not satisfy `c' and all the generators
		//    seen so far are included in `c'.
		return Poly_Con_Relation::strictly_intersects();
	      if (sp_sign > 0)
		// Here all the generators seen so far either saturate
		// or are included in `c'.
		// Since `g' does not saturate `c' ...
		res = Poly_Con_Relation::is_included();
	    }
	  }
	}
	else {
	  // The generator `g' is a vertex.
	  if (first_vertex_or_nonsaturating_ray) {
	    // It is the first time that we have a vertex and
	    // we have not found a non-saturating ray yet.
	    // - If vertex `g' saturates `c', then all the generators
	    //   seen so far saturate `c'.
	    // - If vertex `g' is included (but does not saturate) `c',
	    //   then all the generators seen so far are included in `c'.
	    // - If vertex `g' does not satisfy `c', then all the
	    //   generators seen so far are disjoint from `c'.
	    first_vertex_or_nonsaturating_ray = false;
	    res = (sp_sign > 0) ? Poly_Con_Relation::is_included() :
	      ((sp_sign == 0) ? Poly_Con_Relation::saturates() : Poly_Con_Relation::is_disjoint());
	  }
	  else {
	    // We already found a vertex or a non-saturating ray before.
	    if ((sp_sign >= 0 && res == Poly_Con_Relation::is_disjoint())
		|| (sp_sign < 0 && res != Poly_Con_Relation::is_disjoint()))
	      // We have a strict intersection if either:
	      // - `g' satisfies or saturates `c' but none of the
	      //    generators seen so far are included in `c'; or
	      // - `g' does not satisfy `c' and all the generators
	      //    seen so far are included in `c'.
	      return Poly_Con_Relation::strictly_intersects();
	    if (sp_sign > 0)
	      // Here all the generators seen so far either saturate
	      // or are included in `c'.
	      // Since `g' does not saturate `c' ...
	      res = Poly_Con_Relation::is_included();
	  }
	}
      }
    }
    return res;
  }
}

/*!
  \param v            Index of the column to which the
                      affine transformation is assigned.
  \param expr         The numerator of the affine transformation:
                      \f$\sum_{i = 0}^{n - 1} a_i x_i + b\f$.
  \param denominator  The denominator of the affine transformation.

  We want to allow affine transformations (see the Introduction) having
  any rational coefficients. Since the coefficients of the
  constraints are integers we must also provide an integer \p denominator
  that will be used as denominator of the affine transformation.

  The affine transformation assigns to each element of \p v -th
  column the follow expression:
  \f[
    \frac{\sum_{i = 0}^{n - 1} a_i x_i + b}
         {denominator}.
  \f]

  \p expr is a constant parameter and unaltered by this computation
*/
void
PPL::GenSys::affine_image(size_t v,
			  const LinExpression& expr,
			  const Integer& denominator) {
  GenSys& x = *this;
  size_t num_columns = x.num_columns();
  size_t num_rows = x.num_rows();

  // The first coefficient is the inhomogeneous term.
  assert(v != 0);
  assert(num_columns = expr.size());
  assert(denominator != 0);
  assert(v < num_columns);

  // Computing the numerator of the affine transformation and assigning
  // it to the column of `*this' indexed by `v'.
  for (size_t i = 0; i < num_rows; ++i) {
    Generator& row = x[i];
    row[v] *= expr[v];
    for (size_t j = 0; j < num_columns; ++j)
      if (j != v)
	row[v] += row[j] * expr[j];	
  }
  if (denominator != 1)
    // Since we want integer elements in the matrix and the
    // `v'-th columns is a multiple of `denominator', we
    // multiply by `denominator' all the other columns of `*this'.
    for (size_t i = 0; i < num_rows; ++i)
      for (size_t j = 0; j < num_columns; ++j)
	if (j != v)
	  x[i][j] *= denominator;

  // If the mapping in not invertible,
  // we may have trasformed valid lines and rays
  // into the origin of the space.
  if (expr[v] == 0)
    x.remove_invalid_lines_and_rays();

  x.strong_normalize();
}

/*!
  Like <CODE>ConSys::print()</CODE>, this prints the number of rows,
  the number of columns and value of \p sorted, using the
  <CODE>Matrix::print()</CODE> method, then prints the contents of
  all the rows, specifying whether a row represent a line or a vertex/ray.
*/
void
PPL::GenSys::print(std::ostream& s) const {
  Matrix::print(s);
  const char separator = ' ';
  const GenSys& x = *this;
  for (size_t i = 0; i < x.num_rows(); ++i) {
    for (size_t j = 0; j < x.num_columns(); ++j)
      s << x[i][j] << separator;
    s << separator << separator
      << (x[i].is_ray_or_vertex()
	  ? (x[i][0] == 0 ? "R" : "V")
	  : "L")
      << std::endl;
  }
}

/*!
  Like <CODE>ConSys::get()</CODE>, this uses <CODE>Matrix::get()</CODE>
  to resize the matrix of generators taking information from \p s,
  then initializes the coefficients of each generator and its type
  (line or ray/vertex).
*/
void
PPL::GenSys::get(std::istream& s) {
  Matrix::get(s);
  std::string tempstr;
  GenSys& x = *this;
  for (size_t i = 0; i < x.num_rows(); ++i) {
    for (size_t j = 0; j < x.num_columns(); ++j)
      s >> x[i][j];
    s >> tempstr;
    if (tempstr == "L")
      x[i].set_is_line();
    else if (tempstr == "R" || tempstr == "V")
      x[i].set_is_ray_or_vertex();
    else
      throw std::runtime_error("void PPL::GenSys::get(s)");
  }
}

void
PPL::GenSys::remove_invalid_lines_and_rays() {
  // The origin of the vector space cannot be a valid line/ray.
  GenSys& gs = *this;
  size_t num_rows = gs.num_rows();
  for (size_t i = num_rows; i-- > 0; ) {
    Generator& g = gs[i];
    if (g[0] == 0 && g.all_homogeneous_terms_are_zero()) {
      // An invalid line/ray has been found.
      --num_rows;
      std::swap(g, gs[num_rows]);
      gs.set_sorted(false);
    }
  }
  gs.erase_to_end(num_rows);
}

/*!
  Returns <CODE>true</CODE> if and only if \p *this actually represents
  a system of generators. So, \p *this must satisfy some rule:
  -# it must have a column for the inhomogeneous term and one for
     a variable;
  -# it can have no row; otherwise it must have at least a vertex;
  -# every line and ray must have the inhomogeneous term equal to zero;
  -# the inhomogeneous term of all vertices must be positive.
*/
bool
PPL::GenSys::OK() const {
  using std::endl;
  using std::cerr;

  // A GenSys must be a valid Matrix.
  if (!Matrix::OK())
    return false;

  if (num_rows() == 0)
    // A valid system of generators can be empty.
    return true;

  bool no_vertex = true;
  for (size_t i = num_rows(); i-- > 0; ) {
    const Generator& g = (*this)[i];

    if (!g.OK())
      return false;

    // Looking for a vertex.
    if (g.is_ray_or_vertex() && g[0] != 0)
      // We found a vertex.
      no_vertex = false;
  }

  if (no_vertex) {
    // A valid, non-empty system
    // of generators must have at least one vertex.
    cerr << "There must be at least one vertex!"
	 << endl;
    return false;
  }

  return true;
}
