
Enhancements for PPL 0.10
=========================

- Have a look at

    http://www.inf.ethz.ch/personal/gonnet/FPAccuracy/Analysis.html

  especially at the "Surprises" section, where it talks about
  rounding problems for division and multiplication on Pentium/AMD.

- Provide PPL-specific documentation on the use of `make check'
  and `make uninstall'.

- Add a short section to the user documentation explaining how to
  compile and link (at least under Un*x) an application using the PPL
  through the C and C++ interface (this information is already provided
  for the Prolog interfaces).  This section should also mention the
  programs in the demos directory (they constitute additional examples
  of use of the C and C++ interfaces) and in the directories under tests
  (these are currently covered by a README file).

- Suppose we want to sum three numbers, and suppose we do it by

  Â  add(T& to, const T& x, const T& y, const T& z) {
Â      add(to, x, y);
Â      add(to, to, z);
Â    }

Â  Now suppose that &to == &z, so that we compute the wrong result.
  Perform a code audit to ensure that the above situation never happens.
  In order to ensure that, ensure that the following rule (to be added
  to STANDARDS) is always obeyed:

    if an argument of type T and passed by reference is changed,
    after the change no argument of type U and passed by const or
    non-const reference should be read unless U is incompatible with T
    or we are otherwise 100% sure that the changed argument and the
    argument that is read afterward are not aliases (in the latter
    case an assert(&to != &z) shall be added.

- Define functions rem() and remp() to compute the remainder of division
  in the general case, for rem(), and in the case where the second
  argument is known to be positive, for remp().  In the implementation
  of rem(), if CXX_HAS_REMAINDER_BUG is nonzero, a suitable workaround
  should be implemented to circumvent the INT_MIN % -1 bug.
  rem() and remp() should be used (with a strong preference to the second,
  of course) wherever we now use operator%().
- Pointset_Powerset lacks many methods: affine_image() has just been added,
  but all the others should follow.
- Update the examples in README.configure.
- Fix the dependency problems in interfaces/OCaml/Makefile.am.
- Using meta_programming.hh it is possible to define all the swap functions
  "automatically".  Consider whether it is worth doing it.
- In the SWI-Prolog documentation, the command to dynamically
  load the library has to be modified so as to specify the `.so'
  extension: this is required under Mac OS X and seems not to
  do any harm under GNU/Linux.
- Add a "quick assign" function to checked numbers that allows
  to efficiently assign small integer constants (like those in
  the range [-2, 2]) that are guaranteed not to cause any
  rounding or overflow problems.
- Check all the Makefile.am's to make sure CLEANFILES, MOSTLYCLEANFILES
  and DISTCLEANFILES are used in a sensible way.
- Revise the documentation for all the congruences() and
  minimized_congruences() methods.
- Ensure the tests in tests/MIP_Problem/* cover every line of
  code in MIP_Problem.*.
- `make check' in ppl_lpsol must run also the incremental version
  of the simplex solver.
- MIP_Problem: ensure ascii_load() and operator<< are correct.
- Develop a C and Prolog interfaces for all the supported domains.
- Incorporate the domain of intervals.
- Reduce the number of FIXMEs to no more than 20.
- Complete the manual pages for ppl-config, ppl_lpsol and ppl_lcdd.
- Write a manual page for ppl (3).
- Provide a single, generic implementation to replace all our status
  classes.
- Clearly explain, in the documentation, how (not) to use
  set_GMP_memory_allocation_functions().  More generally, explain how
  to have memory-guarded computations.
- Reconsider the handling of temporary coefficients.
- Provide a generic implementation for the `widening with tokens'.
- Direct_Product: Check that all comments and code are consistent with
  intended semantics.

Enhancements for PPL 0.10 or later versions
==========================================

- Consider whether or not our interface for method time_elapse_assign()
  is the one needed by users: in particular, see if it should take as
  an argument a generator system, instead of an abstract element.
- In the OK() methods, instead of having all those #ifndef NDEBUG,
  it is probably worthwhile to use a suitable defined `barf' stream
  that does the right thing.
- Provide support for strict inequalities in MIP problems.
- Implement void Polyhedron::envelope_assign(const Polyhedron& y).
- Implement the extrapolation operators defined in HenzingerH95
  and HenzingerPW01.
- See whether, using the techniques described in
  ftp://ftp.ifor.math.ethz.ch/pub/fukuda/reports/polyunion001120.ps.gz
  we can implement bool poly_hull_assign_if_exact(PH& p, const PH& q),
  temporarily in algorithms.hh, more efficiently.
- Provide optimized implementations of Polyhedron::expand_dimension()
  Polyhedron::fold_dimensions().
- Experiment with different compilation flags, such as GCC's
  `-fno-threadsafe-statics'.
- Suppose we are only interested in integral solutions (as is the
  case, e.g., in most termination analyses).  Then cutting-plane methods
  (Gomory, Chvátal, ...) allow to shrink polyhedra still not losing any
  integral solution.
  See http://www.cs.unipr.it/ppl/Documentation/bibliography#NemhauserW88
  Check the work by Kent Andersen and Gérard Cornuéjols on
  reduce-and-split cuts.
- Add an implementation of Minkowski addition.  Check the algorithm
  described in

    K. Fukuda.
    From the zonotope construction to the Minkowski addition
    of convex polytopes.
    J. Symbolic Comput., 38(4):1261-1272, 2004.


Efficiency Issues
=================

- There must be a more efficient way to implement
  bool Polyhedron::is_disjoint_from(const Polyhedron&).
- There must be a more efficient way to compute convex
  differences.
- We are being rather careless about the creation of temporaries
  as far as the classes Linear_Expression, Constraint and Generator
  are concerned.
- Provide a better implementation of computing squares in MIP_Problem's
  steepest-edge to avoid big numbers.

Debian packaging
================

- Add an interface package for each Prolog as a suitable version of
  that Prolog appears in Debian.  Control entries for these are in
  control.prologs.
- Find out if /usr/lib/pkgconfig entries are required in any packages.
- libppl-dev is very large.  Consider moving the docs to libppl-doc
  and the other files into libppl.
- Verify the Build-Depends and Build-Depends-Indep settings, as per
  the Debian Developers Reference section 5.10.1 point 1.
- Consider renaming libppl-pwl to libpwl.
