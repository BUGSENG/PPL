
Enhancements for PPL 0.10
=========================

- Complete and improve the following text.  Modify the library
  interfaces consequently, then add (an elaboration of) this text
  to the manuals.

Kinds of geometric descriptors
------------------------------

The PPL supports several kinds of <EM>geometric descriptor</EM> (GD
for short).  The top-level components provided by the PPL are called
<EM>semantic GDs</EM> and denote a subset of \f$ \Rset^n \f$, while
the lower-level components, which are called <EM>syntactic GDs</EM>,
provide a means for describing a semantic GD and its properties in
terms that are completely independent from the semantic GD's internal
representation.


Semantic geometric descriptors
------------------------------

A <EM>semantic geometric descriptor</EM> is a subset of \f$ \Rset^n \f$.
The PPL provides several classes of semantic GDs.  These are
identified by their C++ class name, together with the class template
parameters, if any. A uniform set of operations is provided for
creating, testing and maintaining each of the semantic GDs.
However, as most of these will depend on one or more syntactic GDs,
we first describe the syntactic GDs.

Syntactic geometric descriptors
-------------------------------

A <EM>syntactic geometric descriptor</EM> is for defining, modifying
and inspecting a semantic GD.  There are three kinds of <EM>syntactic
GDs</EM>: <EM>basic GDs</EM>, <EM>constraint GDs</EM>> and
<EM>generator GDs</EM>. Some of these are <EM>generic</EM> and some
<EM>specific</EM>; a generic syntactic GD is characterized by having a
fixed meaning independent of its use while a specific syntactic GD
has a meaning that is dependent on the semantic GD with which it is
used.

Basic geometric descriptors
---------------------------

The following basic GDs currently supported by
the PPL are:

1) space dimension
2) variable and variable set
3) coefficient
5) linear expression
4) relation symbol

These classes, which are all generic syntactic GDs, are used
to build the constraint and generator GDs as
well as support many generic operations on the semantic GDs.

Constraint geometric descriptors
--------------------------------

The PPL currently supports the following classes of constraint GDs:

1) linear constraint, which denotes a hyperplane;
2) linear constraint system, which denotes a hyperspace;
3) linear congruence;
4) linear congruence system;

All these classes are generic syntactic GDs.
However, a semantic GD may only capture the precise
meaning of a subset of the constraint GDs and any semantic
GD operation that cannot capture the semantics of the constraint GD
precisely will either indicate its unsuitability or apply an upward
approximation semantics.

Generator geometric descriptors
-------------------------------

The PPL currently supports two classes of generator GDs.

1) Polyhedra generator: these are polyhedra points, rays and lines.
   Notice that rays and lines are "space operators" that do not make
   sense in themselves: they need a space to operate upon.
2) Grid generator: these are grid points, parameters and grid lines.
   Notice that parameters and grid lines are "space operators" that
   do not make sense in themselves: they need a space to operate upon.

These classes are specific syntactic GDs since they can only be used
by the appropriate classes. However there is an exception to this and a
polyhedron point is also used in some generic PPL operations where it
is interpreted as a point in the considered vector space.

Generic operations on semantic geometric descriptors
----------------------------------------------------

a) Constructors of a universe or empty semantic GD with the given
   space dimension.

b) Operations on a semantic GD that do not depend on the syntactic GDs.

o  is_empty(), is_universe(), is_topologically_closed(),
   is_discrete(), is_bounded(), contains_integer_point()

   test for the named properties of the semantic GD.

o  total_memory_in_bytes(), external_memory_in_bytes()

   return the total and external memory size in bytes.

o  OK()

   checks that the semantic GD has a valid internal representation.
   An optional Boolean argument allows a check for emptiness.

o  space_dimension(), affine_dimension()

   returns, respectively, the space and affine dimensions of the GD.

o  add_space_dimensions_and_embed(), add_space_dimensions_and_project(),
   expand_space_dimension(), remove_space_dimensions(),
   fold_space_dimensions() map_space_dimensions()

   modify the space dimensions of the semantic GD; where, depending on the
   operation, the arguments can include the number of space dimensions
   to be added or removed a variable or set of variables denoting the
   actual dimensions to be used and a partial function defining a mapping
   between the dimensions.

o  contains(), strictly_contains() is_disjoint_from()

   compare the semantic GD with an argument semantic GD of the same class.

o  topological_closure_assign(), intersection_assign(),
   intersection_assign_and_minimize(), upper_bound_assign(),
   difference_assign(), time_elapse_assign(), widening_assign(),
   concatenate_assign(), swap()

   modify the semantic GD, possibly with an argument semantic GD of
   the same class.

o  constrains(), bounds_from_above(), bounds_from_below(),
   maximize(), minimize().

   These find information about the bounds of the semantic GD where
   the argument variable or linear expression define the direction
   of the bound.

o  affine_image(), affine_preimage(),
   generalized_affine_image(), generalized_affine_preimage(),
   bounded_affine_image(), bounded_affine_preimage().

   These perform several variations of the affine image and preimage
   operations where, depending on the operation, the arguments can
   include a variable representing the space dimension to which the
   transformation will be applied and linear expressions
   with possibly a relation symbol and denominator value
   that define the exact form of the transformation.

o  ascii_load(), ascii_dump()

   are the ascii input and output operations.

b) Constructors of a semantic GD of one class from a semantic GD of any
   other class.

   These constructors obey an <EM>upward approximation semantics</EM>,
   meaning that the constructed semantic GD is guaranteed to contain
   all the points of the source semantic GD, but possibly more.
   Some of <SHOULD WE REPLACE SOME OF WITH ALL HERE?> these constructors
   provide a complexity parameter with which the application can control
   the complexity/precision trade-off for the construction operation.

<TO BE COMPLETED>

c) Constructors of a semantic GD from a constraint GD;
   either a linear constraint system or a linear congruence system.
   If the semantic GD cannot capture the precise meaning of the constraint GD
   then it indicates its unsuitability by throwing an "invalid argument"
   exception to signal that the operation could not be performed.

e) Other interraction between the semantic GDs and constraint GDs

o  add_constraint(), add_constraint_and_minimize(),
   add_constraints(), add_constraints_and_minimize(),
   add_recycled_constraints(), add_recycled_constraints_and_minimize(),
   add_congruence(), add_congruence_and_minimize(),
   add_congruences(), add_congruences_and_minimize(),
   add_recycled_congruences(), add_recycled_congruences_and_minimize().

   If the argument constraint GD can be completely incorporated into
   the semantic GD, this is what is done.  Otherwise an "invalid argument"
   exception is thrown to signal that the operation could not be performed.
   For example: the C_Polyhedron class can incorporate any non-strict
   linear constraint or equality congruence, but cannot incorporate
   a strict constraint or a proper congruence.  A BD_Shape<T> class can
   incorporate bounded-difference non-strict constraints, but not more
   complex linear constraints.  An invariant of these
   methods is that, if they successfully add a constraint GD, then
   an enquiry for the same constraint GD with a "relation with" method
   is guaranteed to yield a "definitely implied" result.

o  refine_with_constraint(), refine_with_constraints(),
   refine_with_recycled_constraints(),
   refine_with_congruence(), refine_with_congruences()
   refine_with_recycled_congruences()

   If the argument constraint GD can be completely incorporated into
   the semantic GD, this is what is done.  Otherwise the constraint
   GD is used only to a limited extent to refine the semantic GD;
   possibly not at all.  Notice that, while repeating an add operation
   is pointless, this is not true for the refine operations.
   For example, in those cases where

     Semantic_GD.add_constraint(c)

   raises an exception, a fragment of the form

     Semantic_GD.refine_with_constraint(c)
     // Other add_constraint(s) or refine_with_constraint(s) operations
     // on Semantic_GD.
     Semantic_GD.refine_with_constraint(c)

   may give more precise results than a single

     Semantic_GD.refine_with_constraint(c).


<TO BE CONTINUED>

Upward approximation
--------------------

The Parma Polyhedra Library, for those cases where an exact result
cannot be computed within the specified complexity limits, computes an
<EM>upward approximation</EM> of the exact result.  For semantic GDs this
means that the computed result is a possibly strict superset of the set of
points of \f$ \Rset^n \f$ that constitutes the exact result.  Notice
that the PPL does not provide direct support to compute <EM>downward
approximations</EM> (i.e., possibly strict subsets of the exact
results).  While downward approximations can often be computed from
upward ones, the required algorithms and the conditions upon which
they are correct are outside the current scope of the PPL.
Beware, in particular, of the following possible pitfall:
the library provides methods to compute upward approximations
of set-theoretic difference, which is antitone in its second
argument.  Applying a difference method to a second argument
that is not an exact representation or a downward approximation of
reality, would yield a result that, of course, is not an upward
approximation of reality.  It is the responsibility of the
library user to provide the PPL's method with approximations of reality
that are consistent with respect to the desired results.



------------------------------------------------------------------------------


- For iterating over a Bit_Row object, unsigned long is overkill:
  replace with unsigned int.

- Consider renaming Bit_Row::empty() Bit_Row::is_empty().

- Write interfaces/OCaml/README.ocaml.

- Provide PPL-specific documentation on the use of `make check'.

- Add a short section to the user documentation explaining how to
  compile and link (at least under Un*x) an application using the PPL
  through the C and C++ interface (this information is already provided
  for the Prolog interfaces).  This section should also mention the
  programs in the demos directory (they constitute additional examples
  of use of the C and C++ interfaces) and in the directories under tests
  (these are currently covered by a README file).

- Suppose we want to sum three numbers, and suppose we do it by

    add(T& to, const T& x, const T& y, const T& z) {
      add(to, x, y);
      add(to, to, z);
    }

  Now suppose that &to == &z, so that we compute the wrong result.
  Perform a code audit to ensure that the above situation never happens.
  In order to ensure that, ensure that the following rule (to be added
  to STANDARDS) is always obeyed:

    if an argument of type T and passed by reference is changed,
    after the change no argument of type U and passed by const or
    non-const reference should be read unless U is incompatible with T
    or we are otherwise 100% sure that the changed argument and the
    argument that is read afterward are not aliases (in the latter
    case an assert(&to != &z) shall be added.

- Define functions rem() and remp() to compute the remainder of division
  in the general case, for rem(), and in the case where the second
  argument is known to be positive, for remp().  In the implementation
  of rem(), if CXX_HAS_REMAINDER_BUG is nonzero, a suitable workaround
  should be implemented to circumvent the INT_MIN % -1 bug.
  rem() and remp() should be used (with a strong preference to the second,
  of course) wherever we now use operator%().
- Update the examples in README.configure.
- Fix the dependency problems in interfaces/OCaml/Makefile.am.
- In the SWI-Prolog documentation, the command to dynamically
  load the library has to be modified so as to specify the `.so'
  extension: this is required under Mac OS X and seems not to
  do any harm under GNU/Linux.
- Check all the Makefile.am's to make sure CLEANFILES, MOSTLYCLEANFILES
  and DISTCLEANFILES are used in a sensible way.
- Ensure the tests in tests/MIP_Problem/* cover every line of
  code in MIP_Problem.*.
- `make check' in ppl_lpsol must run also the incremental version
  of the simplex solver.
- MIP_Problem: ensure ascii_load() and operator<< are correct.
- Incorporate the domain of intervals.
- Reduce the number of FIXMEs to no more than 20.
- Complete the manual pages for ppl-config, ppl_lpsol and ppl_lcdd.
- Write a manual page for ppl (3).
- Clearly explain, in the documentation, how (not) to use
  set_GMP_memory_allocation_functions().  More generally, explain how
  to have memory-guarded computations.
- Octagonal_Shape relation_with_constraints and BD_Shape
  relation_with_constraints should consider constraints
  that are not octagonal, resp., bd_shapes; at present
  they throw an exception when these conditions are not met.
- Octagonal_Shape relation_with_congruences and BD_Shape
  relation_with_congruences construct the equivalent polyhedron
  and use the Polyhedron relation_with_congruences method.
  These should be rewritten to work directly with the shape domain.

Enhancements for PPL 0.10 or later versions
===========================================

- Add a "quick assign" function to checked numbers that allows
  to efficiently assign small integer constants (like those in
  the range [-2, 2]) that are guaranteed not to cause any
  rounding or overflow problems.
- Consider whether or not our interface for method time_elapse_assign()
  is the one needed by users: in particular, see if it should take as
  an argument a generator system, instead of an abstract element.


Enhancements for PPL 0.11 or later versions
===========================================

- Provide a generic implementation for the `widening with tokens'.
- In the OK() methods, instead of having all those #ifndef NDEBUG,
  it is probably worthwhile to use a suitable defined `barf' stream
  that does the right thing.
- Using meta_programming.hh it is possible to define all the swap functions
  "automatically".  Consider whether it is worth doing it.
- Provide a single, generic implementation to replace all our status
  classes.
- Implement the extrapolation operators defined in HenzingerH95
  and HenzingerPW01.
- Implement void Polyhedron::envelope_assign(const Polyhedron& y).
- Provide support for strict inequalities in MIP problems.
- See whether, using the techniques described in
  ftp://ftp.ifor.math.ethz.ch/pub/fukuda/reports/polyunion001120.ps.gz
  we can implement bool poly_hull_assign_if_exact(PH& p, const PH& q),
  temporarily in algorithms.hh, more efficiently.
- Provide optimized implementations of Polyhedron::expand_dimension()
  Polyhedron::fold_dimensions().
- Suppose we are only interested in integral solutions (as is the
  case, e.g., in most termination analyses).  Then cutting-plane methods
  (Gomory, Chvátal, ...) allow to shrink polyhedra still not losing any
  integral solution.
  See http://www.cs.unipr.it/ppl/Documentation/bibliography#NemhauserW88
  Check the work by Kent Andersen and Gérard Cornuéjols on
  reduce-and-split cuts.
- Add an implementation of Minkowski addition.  Check the algorithm
  described in

    K. Fukuda.
    From the zonotope construction to the Minkowski addition
    of convex polytopes.
    J. Symbolic Comput., 38(4):1261-1272, 2004.


Efficiency Issues
=================

- There must be a more efficient way to implement
  bool Polyhedron::is_disjoint_from(const Polyhedron&).
- There must be a more efficient way to compute convex differences.
- We are being rather careless about the creation of temporaries
  as far as the classes Linear_Expression, Constraint and Generator
  are concerned.
- Provide a better implementation of computing squares in MIP_Problem's
  steepest-edge to avoid big numbers.

Debian packaging
================

- Add an interface package for each Prolog as a suitable version of
  that Prolog appears in Debian.  Control entries for these are in
  control.prologs.
- Find out if /usr/lib/pkgconfig entries are required in any packages.
- libppl-dev is very large.  Consider moving the docs to libppl-doc
  and the other files into libppl.
- Verify the Build-Depends and Build-Depends-Indep settings, as per
  the Debian Developers Reference section 5.10.1 point 1.
- Consider renaming libppl-pwl to libpwl.
