
Enhancements for PPL 0.10
=========================

- Complete and improve the following text.  Modify the library
  interfaces consequently, then add (an elaboration of) this text
  to the manuals.

Kinds of geometric descriptions
-------------------------------

The PPL offers way to create and manipulate two kinds of geometric
descriptions (GD for short): the <EM>syntactic</EM> GDs and
the <EM>semantic</EM> GDs.  The semantic GDs capture the essence of
geometric objects;  the syntactic GDs provide the language with which
an application can specify semantic GDs in terms that are completely
independent from the semantic GDs internal representation.


Semantic geometric descriptions
-------------------------------

A <EM>semantic geometric description</EM> is a subset of \f$ \Rset^n \f$.
The PPL provides several classes of semantic GDs.  These are identified
by their C++ class name, together with the class template parameters,
if any.  The PPL provides the following kinds of operations on all semantic
GDs:

a) Operations on semantic GDs of the same class:

   <LIST THEM ALL HERE>

b) Constructors of a semantic GD of one class from a semantic GD of any
   other class.

   These constructors obey an <EM>upward approximation semantics</EM>,
   meaning that the constructed semantic GD is guaranteed to contain
   all the points of the source semantic GD, but possibly more.
   Some <SHOULD WE REPLACE SOME WITH ALL HERE?> such constructors
   provide a complexity parameter with which the application can control
   the complexity/precision trade-off for the construction operation.


Syntactic geometric descriptions
--------------------------------

A <EM>syntactic geometric description</EM> is an object that can be used
by the application to define, modify and inspect a semantic GD.
The PPL offers two kinds of syntactic GDs:
<EM>generic</EM> syntactic GDs and <EM>specific</EM> syntactic GDs.


Generic syntactic geometric descriptions
----------------------------------------

A <EM>generic</EM> syntactic GD is characterized by possessing a semantics
that is completely internally defined.  In other words, the meaning of
a generic syntactic GD depends neither on the class of semantic GD with
which it can be used, nor on the presence or absence of other syntactic
GDs.  The PPL currently supports two classes of generic syntactic GD:

1) linear constraints, which denote hyperplanes and hyperspaces;
2) linear congruences.


Specific syntactic geometric descriptions
-----------------------------------------

In contrast with the <EM>generic</EM> ones, the meaning of a
<EM>specific</EM> syntactic GDs may depend on the semantic GDs that
constitutes the "universe of discourse" and/or on the presence or
absence of other syntactic GDs.  The PPL currently supports two classes
of specific syntactic GD:

1) Polyhedra generator: these are polyhedra points, rays and lines.
   Notice that rays do not make sense on, e.g, grids.  Notice also that
   rays and lines are "space operators" that do not make sense in
   themselves: they need a space to operate upon.
2) Grid generators.


Interaction between the semantic and syntactic geometric descriptions
---------------------------------------------------------------------

From the discussion above, it is clear that, while specific syntactic GDs
are only usable with respect to the corresponding semantic GDs,
generic syntactic GDs can be used to interact with any semantic GD.
However, it must be clear that any semantic GDs can only be expected
to fully capture a subset of the generic syntactic GDs;  for the others
the semantic GD will either signal its unsuitability or will apply
the upward approximation semantics.  We list below the methods along
with an informal description of their semantics:

o  add_constraint(), add_constraints(), add_congruence(), add_congruences()

   If the argument syntactic GD can be completely incorporated into
   the semantic GD, this is what is done.  Otherwise an "invalid argument"
   exception is thrown to signal that the operation could not be performed.
   For example: the C_Polyhedron class can incorporate any non-strict
   linear constraint, but cannot incorporate strict constraints or
   non-trivial congruences.  A BD_Shape<T> class can incorporate
   bounded-difference non-strict constraints, but not more complex
   linear constraints.  An invariant that is satisfied by these method
   is that successfully adding one or more syntactic GDs and then enquiring
   with any of them with the "relation with" methods is guaranteed to
   yield a "definitely implied" result.


o  refine_with_constraint(), refine_with_constraints(),
   refine_with_congruence(), refine_with_congruences()

   If the argument syntactic GD can be completely incorporated into
   the semantic GD, this is what is done.  Otherwise the syntactic
   GD is used only to a limited extent to refine the semantic GD;
   possibly not at all.  Notice that, while repeating an add operation
   is pointless, this is not true for the refine operations.
   For example, in those cases where

     Semantic_GD.add_constraint(c)

   raises an exception, a fragment of the form

     Semantic_GD.refine_with_constraint(c)
     // Other add_constraint(s) or refine_with_constraint(s) operations
     // on Semantic_GD.
     Semantic_GD.refine_with_constraint(c)

   can give more precise results than a single

     Semantic_GD.refine_with_constraint(c).


<TO BE CONTINUED>



- For iterating over a Bit_Row object, unsigned long is overkill:
  replace with unsigned int.

- Consider renaming Bit_Row::empty() Bit_Row::is_empty().

- Write interfaces/OCaml/README.ocaml.

- Provide PPL-specific documentation on the use of `make check'.

- Add a short section to the user documentation explaining how to
  compile and link (at least under Un*x) an application using the PPL
  through the C and C++ interface (this information is already provided
  for the Prolog interfaces).  This section should also mention the
  programs in the demos directory (they constitute additional examples
  of use of the C and C++ interfaces) and in the directories under tests
  (these are currently covered by a README file).

- Suppose we want to sum three numbers, and suppose we do it by

    add(T& to, const T& x, const T& y, const T& z) {
      add(to, x, y);
      add(to, to, z);
    }

  Now suppose that &to == &z, so that we compute the wrong result.
  Perform a code audit to ensure that the above situation never happens.
  In order to ensure that, ensure that the following rule (to be added
  to STANDARDS) is always obeyed:

    if an argument of type T and passed by reference is changed,
    after the change no argument of type U and passed by const or
    non-const reference should be read unless U is incompatible with T
    or we are otherwise 100% sure that the changed argument and the
    argument that is read afterward are not aliases (in the latter
    case an assert(&to != &z) shall be added.

- Define functions rem() and remp() to compute the remainder of division
  in the general case, for rem(), and in the case where the second
  argument is known to be positive, for remp().  In the implementation
  of rem(), if CXX_HAS_REMAINDER_BUG is nonzero, a suitable workaround
  should be implemented to circumvent the INT_MIN % -1 bug.
  rem() and remp() should be used (with a strong preference to the second,
  of course) wherever we now use operator%().
- Update the examples in README.configure.
- Fix the dependency problems in interfaces/OCaml/Makefile.am.
- In the SWI-Prolog documentation, the command to dynamically
  load the library has to be modified so as to specify the `.so'
  extension: this is required under Mac OS X and seems not to
  do any harm under GNU/Linux.
- Check all the Makefile.am's to make sure CLEANFILES, MOSTLYCLEANFILES
  and DISTCLEANFILES are used in a sensible way.
- Ensure the tests in tests/MIP_Problem/* cover every line of
  code in MIP_Problem.*.
- `make check' in ppl_lpsol must run also the incremental version
  of the simplex solver.
- MIP_Problem: ensure ascii_load() and operator<< are correct.
- Incorporate the domain of intervals.
- Reduce the number of FIXMEs to no more than 20.
- Complete the manual pages for ppl-config, ppl_lpsol and ppl_lcdd.
- Write a manual page for ppl (3).
- Clearly explain, in the documentation, how (not) to use
  set_GMP_memory_allocation_functions().  More generally, explain how
  to have memory-guarded computations.
- Octagonal_Shape relation_with_constraints and BD_Shape
  relation_with_constraints should consider constraints
  that are not octagonal, resp., bd_shapes; at present
  they throw an exception when these conditions are not met.
- Octagonal_Shape relation_with_congruences and BD_Shape
  relation_with_congruences construct the equivalent polyhedron
  and use the Polyhedron relation_with_congruences method.
  These should be rewritten to work directly with the shape domain.

Enhancements for PPL 0.10 or later versions
===========================================

- Add a "quick assign" function to checked numbers that allows
  to efficiently assign small integer constants (like those in
  the range [-2, 2]) that are guaranteed not to cause any
  rounding or overflow problems.
- Consider whether or not our interface for method time_elapse_assign()
  is the one needed by users: in particular, see if it should take as
  an argument a generator system, instead of an abstract element.


Enhancements for PPL 0.11 or later versions
===========================================

- Provide a generic implementation for the `widening with tokens'.
- In the OK() methods, instead of having all those #ifndef NDEBUG,
  it is probably worthwhile to use a suitable defined `barf' stream
  that does the right thing.
- Using meta_programming.hh it is possible to define all the swap functions
  "automatically".  Consider whether it is worth doing it.
- Provide a single, generic implementation to replace all our status
  classes.
- Implement the extrapolation operators defined in HenzingerH95
  and HenzingerPW01.
- Implement void Polyhedron::envelope_assign(const Polyhedron& y).
- Provide support for strict inequalities in MIP problems.
- See whether, using the techniques described in
  ftp://ftp.ifor.math.ethz.ch/pub/fukuda/reports/polyunion001120.ps.gz
  we can implement bool poly_hull_assign_if_exact(PH& p, const PH& q),
  temporarily in algorithms.hh, more efficiently.
- Provide optimized implementations of Polyhedron::expand_dimension()
  Polyhedron::fold_dimensions().
- Suppose we are only interested in integral solutions (as is the
  case, e.g., in most termination analyses).  Then cutting-plane methods
  (Gomory, Chvátal, ...) allow to shrink polyhedra still not losing any
  integral solution.
  See http://www.cs.unipr.it/ppl/Documentation/bibliography#NemhauserW88
  Check the work by Kent Andersen and Gérard Cornuéjols on
  reduce-and-split cuts.
- Add an implementation of Minkowski addition.  Check the algorithm
  described in

    K. Fukuda.
    From the zonotope construction to the Minkowski addition
    of convex polytopes.
    J. Symbolic Comput., 38(4):1261-1272, 2004.


Efficiency Issues
=================

- There must be a more efficient way to implement
  bool Polyhedron::is_disjoint_from(const Polyhedron&).
- There must be a more efficient way to compute convex differences.
- We are being rather careless about the creation of temporaries
  as far as the classes Linear_Expression, Constraint and Generator
  are concerned.
- Provide a better implementation of computing squares in MIP_Problem's
  steepest-edge to avoid big numbers.

Debian packaging
================

- Add an interface package for each Prolog as a suitable version of
  that Prolog appears in Debian.  Control entries for these are in
  control.prologs.
- Find out if /usr/lib/pkgconfig entries are required in any packages.
- libppl-dev is very large.  Consider moving the docs to libppl-doc
  and the other files into libppl.
- Verify the Build-Depends and Build-Depends-Indep settings, as per
  the Debian Developers Reference section 5.10.1 point 1.
- Consider renaming libppl-pwl to libpwl.
