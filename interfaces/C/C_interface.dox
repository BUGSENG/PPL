/* Doxumentation for the C language interface.
   Copyright (C) 2001-2008 Roberto Bagnara <bagnara@cs.unipr.it>

This file is part of the Parma Polyhedra Library (PPL).

The PPL is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 3 of the License, or (at your
option) any later version.

The PPL is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02111-1307, USA.

For the most up-to-date information see the Parma Polyhedra Library
site: http://www.cs.unipr.it/ppl/ . */

/*! \defgroup Polyhedron Convex Polyhedra
  \brief
  Types and functions for the domains of (topologically closed and
  not necessarily closed) convex polyhedra.

  The types and functions for convex polyhedra provide a single interface
  for accessing both topologically closed (C) and not necessarily closed (NNC)
  convex polyhedra.
  The distinction between C and NNC polyhedra need only be explicitly
  stated when <em>creating</em> or <em>assigning</em> a polyhedron object,
  by means of one of the functions <code>ppl_new_*</code> and
  <code>ppl_assign_*</code>.

  Having a single datatype does not mean that C and NNC polyhedra can be
  freely interchanged: as specified in the main manual, most library
  functions require their arguments to be topologically and/or
  space-dimension compatible.
*/
/*@{*/


/*! \name Opaque Pointers for Polyhedra */
/*@{*/

/*! \brief Opaque pointer. */
typedef struct ppl_Polyhedron_tag* ppl_Polyhedron_t;

/*! \brief Opaque pointer to const object. */
typedef struct ppl_Polyhedron_tag const* ppl_const_Polyhedron_tag;

/*@}*/ /* \name Opaque Pointers Related to Polyhedra */


/*! \name Constructors, Assignment and Destructor */
/*@{*/

/*! \brief
  Builds a C polyhedron of dimension \p d and writes an handle to it
  at address \p pph. If \p empty is different from zero, the newly created
  polyhedron will be empty; otherwise, it will be a universe polyhedron.
*/
int
ppl_new_C_Polyhedron_from_space_dimension(ppl_Polyhedron_t* pph,
				          ppl_dimension_type d,
				          int empty);

/*! \brief
  Builds an NNC polyhedron of dimension \p d and writes an handle to it
  at address \p pph. If \p empty is different from zero, the newly created
  polyhedron will be empty; otherwise, it will be a universe polyhedron.
*/
int
ppl_new_NNC_Polyhedron_from_space_dimension(ppl_Polyhedron_t* pph,
					    ppl_dimension_type d,
					    int empty);

/*! \brief
  Builds a C polyhedron that is a copy of \p ph; writes a handle
  for the newly created polyhedron at address \p pph.
*/
int
ppl_new_C_Polyhedron_from_C_Polyhedron(ppl_Polyhedron_t* pph,
				       ppl_const_Polyhedron_t ph);

/*! \brief
  Builds a C polyhedron that is a copy of the topological closure
  of the NNC polyhedron \p ph; writes a handle for the newly created
  polyhedron at address \p pph.
*/
int
ppl_new_C_Polyhedron_from_NNC_Polyhedron(ppl_Polyhedron_t* pph,
					 ppl_const_Polyhedron_t ph);

/*! \brief
  Builds an NNC polyhedron that is a copy of the C polyhedron \p ph;
  writes a handle for the newly created polyhedron at address \p pph.
*/
int
ppl_new_NNC_Polyhedron_from_C_Polyhedron(ppl_Polyhedron_t* pph,
					 ppl_const_Polyhedron_t ph);

/*! \brief
  Builds an NNC polyhedron that is a copy of \p ph; writes a handle
  for the newly created polyhedron at address \p pph.
*/
int
ppl_new_NNC_Polyhedron_from_NNC_Polyhedron(ppl_Polyhedron_t* pph,
					   ppl_const_Polyhedron_t ph);

/*! \brief
  Builds a new C polyhedron from the system of constraints
  \p cs and writes a handle for the newly created polyhedron at
  address \p pph.

  The new polyhedron will inherit the space dimension of \p cs.
*/
int
ppl_new_C_Polyhedron_from_Constraint_System
(ppl_Polyhedron_t* pph, ppl_const_Constraint_System_t cs);

/*! \brief
  Builds a new NNC polyhedron from the system of constraints
  \p cs and writes a handle for the newly created polyhedron at
  address \p pph.

  The new polyhedron will inherit the space dimension of \p cs.
*/
int
ppl_new_NNC_Polyhedron_from_Constraint_System
(ppl_Polyhedron_t* pph, ppl_const_Constraint_System_t cs);

/*! \brief
  Builds a new C polyhedron from the system of generators
  \p gs and writes a handle for the newly created polyhedron at
  address \p pph.

  The new polyhedron will inherit the space dimension of \p gs.
*/
int
ppl_new_C_Polyhedron_from_Generator_System(ppl_Polyhedron_t* pph,
					   ppl_const_Generator_System_t gs);

/*! \brief
  Builds a new NNC polyhedron from the system of generators
  \p gs and writes a handle for the newly created polyhedron at
  address \p pph.

  The new polyhedron will inherit the space dimension of \p gs.
*/
int
ppl_new_NNC_Polyhedron_from_Generator_System(ppl_Polyhedron_t* pph,
					     ppl_const_Generator_System_t gs);

/*! \brief
  Builds a new C polyhedron recycling the system of constraints
  \p cs and writes a handle for the newly created polyhedron at
  address \p pph.

  Since \p cs will be <EM>the</EM> system of constraints of the new
  polyhedron, the space dimension is also inherited.

  \warning
  This function modifies the constraint system referenced by \p cs:
  upon return, no assumption can be made on its value.
*/
int
ppl_new_C_Polyhedron_recycle_Constraint_System
(ppl_Polyhedron_t* pph, ppl_Constraint_System_t cs);

/*! \brief
  Builds a new NNC polyhedron recycling the system of constraints
  \p cs and writes a handle for the newly created polyhedron at
  address \p pph.

  Since \p cs will be <EM>the</EM> system of constraints of the new
  polyhedron, the space dimension is also inherited.

  \warning
  This function modifies the constraint system referenced by \p cs:
  upon return, no assumption can be made on its value.
*/
int
ppl_new_NNC_Polyhedron_recycle_Constraint_System(ppl_Polyhedron_t* pph,
						 ppl_Constraint_System_t cs);

/*! \brief
  Builds a new C polyhedron recycling the system of generators
  \p gs and writes a handle for the newly created polyhedron at
  address \p pph.

  Since \p gs will be <EM>the</EM> system of generators of the new
  polyhedron, the space dimension is also inherited.

  \warning
  This function modifies the generator system referenced by \p gs:
  upon return, no assumption can be made on its value.
*/
int
ppl_new_C_Polyhedron_recycle_Generator_System(ppl_Polyhedron_t* pph,
					      ppl_Generator_System_t gs);

/*! \brief
  Builds a new NNC polyhedron recycling the system of generators
  \p gs and writes a handle for the newly created polyhedron at
  address \p pph.

  Since \p gs will be <EM>the</EM> system of generators of the new
  polyhedron, the space dimension is also inherited.

  \warning
  This function modifies the generator system referenced by \p gs:
  upon return, no assumption can be made on its value.
*/
int
ppl_new_NNC_Polyhedron_recycle_Generator_System(ppl_Polyhedron_t* pph,
						ppl_Generator_System_t gs);

/*! \brief
  Builds a new C polyhedron corresponding to an interval-based
  bounding box, writing a handle for the newly created polyhedron at
  address \p pph.

  If an interval of the bounding box is provided with any finite
  but open bound, then the polyhedron is not built and the value
  <CODE>PPL_ERROR_INVALID_ARGUMENT</CODE> is returned.
  The bounding box is accessed by using the following functions,
  passed as arguments:
    \code
      ppl_dimension_type space_dimension()
    \endcode
    returns the dimension of the vector space enclosing the polyhedron
    represented by the bounding box.
    \code
      int is_empty()
    \endcode
    returns 0 if and only if the bounding box describes a non-empty set.
    The function <CODE>is_empty()</CODE> will always be called before the
    other functions. However, if <CODE>is_empty()</CODE> does not
    return 0, none of the functions below will be called.
    \code
      int get_lower_bound(ppl_dimension_type k, int closed,
                          ppl_Coefficient_t n, ppl_Coefficient_t d)
    \endcode
    Let \f$I\f$ the interval corresponding to the <CODE>k</CODE>-th
    space dimension.  If \f$I\f$ is not bounded from below, simply return 0.
    Otherwise, set <CODE>closed</CODE>, <CODE>n</CODE> and
    <CODE>d</CODE> as follows: <CODE>closed</CODE> is set to 0 if the
    lower boundary of \f$I\f$ is open and is set to a value different
    from zero otherwise; <CODE>n</CODE> and <CODE>d</CODE> are
    assigned the integers \f$n\f$ and \f$d\f$ such that the canonical
    fraction \f$n/d\f$ corresponds to the greatest lower bound of
    \f$I\f$.  The fraction \f$n/d\f$ is in canonical form if and only
    if \f$n\f$ and \f$d\f$ have no common factors and \f$d\f$ is
    positive, \f$0/1\f$ being the unique representation for zero.
    \code
      int get_upper_bound(ppl_dimension_type k, int closed,
                          ppl_Coefficient_t n, ppl_Coefficient_t d)
    \endcode
    Let \f$I\f$ the interval corresponding to the <CODE>k</CODE>-th
    space dimension.  If \f$I\f$ is not bounded from above, simply return 0.
    Otherwise, set <CODE>closed</CODE>, <CODE>n</CODE> and
    <CODE>d</CODE> as follows: <CODE>closed</CODE> is set to 0 if the
    upper boundary of \f$I\f$ is open and is set to a value different
    from 0 otherwise; <CODE>n</CODE> and <CODE>d</CODE> are assigned
    the integers \f$n\f$ and \f$d\f$ such that the canonical fraction
    \f$n/d\f$ corresponds to the least upper bound of \f$I\f$.
*/
int
ppl_new_C_Polyhedron_from_bounding_box
(ppl_Polyhedron_t* pph,
 ppl_dimension_type (*space_dimension)(void),
 int (*is_empty)(void),
 int (*get_lower_bound)(ppl_dimension_type k, int closed,
			ppl_Coefficient_t n,
			ppl_Coefficient_t d),
 int (*get_upper_bound)(ppl_dimension_type k, int closed,
			ppl_Coefficient_t n,
			ppl_Coefficient_t d));

/*! \brief
  Builds a new NNC polyhedron corresponding to an interval-based
  bounding box, writing a handle for the newly created polyhedron at
  address \p pph.

  The bounding box is accessed by using the following functions,
  passed as arguments:
    \code
      ppl_dimension_type space_dimension()
    \endcode
    returns the dimension of the vector space enclosing the polyhedron
    represented by the bounding box.
    \code
      int is_empty()
    \endcode
    returns 0 if and only if the bounding box describes a non-empty set.
    The function <CODE>is_empty()</CODE> will always be called before the
    other functions. However, if <CODE>is_empty()</CODE> does not
    return 0, none of the functions below will be called.
    \code
      int get_lower_bound(ppl_dimension_type k, int closed,
                          ppl_Coefficient_t n, ppl_Coefficient_t d)
    \endcode
    Let \f$I\f$ the interval corresponding to the <CODE>k</CODE>-th
    space dimension.  If \f$I\f$ is not bounded from below, simply return 0.
    Otherwise, set <CODE>closed</CODE>, <CODE>n</CODE> and
    <CODE>d</CODE> as follows: <CODE>closed</CODE> is set to 0 if the
    lower boundary of \f$I\f$ is open and is set to a value different
    from zero otherwise; <CODE>n</CODE> and <CODE>d</CODE> are
    assigned the integers \f$n\f$ and \f$d\f$ such that the canonical
    fraction \f$n/d\f$ corresponds to the greatest lower bound of
    \f$I\f$.  The fraction \f$n/d\f$ is in canonical form if and only
    if \f$n\f$ and \f$d\f$ have no common factors and \f$d\f$ is
    positive, \f$0/1\f$ being the unique representation for zero.
    \code
      int get_upper_bound(ppl_dimension_type k, int closed,
                          ppl_Coefficient_t n, ppl_Coefficient_t d)
    \endcode
    Let \f$I\f$ the interval corresponding to the <CODE>k</CODE>-th
    space dimension.  If \f$I\f$ is not bounded from above, simply return 0.
    Otherwise, set <CODE>closed</CODE>, <CODE>n</CODE> and
    <CODE>d</CODE> as follows: <CODE>closed</CODE> is set to 0 if the
    upper boundary of \f$I\f$ is open and is set to a value different
    from 0 otherwise; <CODE>n</CODE> and <CODE>d</CODE> are assigned
    the integers \f$n\f$ and \f$d\f$ such that the canonical fraction
    \f$n/d\f$ corresponds to the least upper bound of \f$I\f$.
*/
int
ppl_new_NNC_Polyhedron_from_bounding_box
(ppl_Polyhedron_t* pph,
 ppl_dimension_type (*space_dimension)(void),
 int (*is_empty)(void),
 int (*get_lower_bound)(ppl_dimension_type k, int closed,
			ppl_Coefficient_t n,
			ppl_Coefficient_t d),
 int (*get_upper_bound)(ppl_dimension_type k, int closed,
			ppl_Coefficient_t n,
			ppl_Coefficient_t d));

/*! \brief
  Assigns a copy of the C polyhedron \p src to the C polyhedron \p dst.
*/
int
ppl_assign_C_Polyhedron_from_C_Polyhedron(ppl_Polyhedron_t dst,
					  ppl_const_Polyhedron_t src);

/*! \brief
  Assigns a copy of the NNC polyhedron \p src to the NNC
  polyhedron \p dst.
*/
int
ppl_assign_NNC_Polyhedron_from_NNC_Polyhedron(ppl_Polyhedron_t dst,
					      ppl_const_Polyhedron_t src);

/*! \brief
  Invalidates the handle \p ph: this makes sure the corresponding
  resources will eventually be released.
*/
int
ppl_delete_Polyhedron(ppl_const_Polyhedron_t ph);

/*@}*/ /* Constructors, Assignment and Destructor */

/*! \name Functions that Do Not Modify the Polyhedron */
/*@{*/

/*! \brief
  Writes to \p m the dimension of the vector space enclosing \p ph.
*/
int
ppl_Polyhedron_space_dimension(ppl_const_Polyhedron_t ph,
			       ppl_dimension_type* m);

/*! \brief
  Writes to \p m the affine dimension of \p ph (not to be confused with the
  dimension of its enclosing vector space) or 0, if \p ph is empty.
*/
int
ppl_Polyhedron_affine_dimension(ppl_const_Polyhedron_t ph,
				ppl_dimension_type* m);

/*! \brief
  Writes a const handle to the constraint system defining the
  polyhedron \p ph at address \p pcs.
*/
int
ppl_Polyhedron_constraints(ppl_const_Polyhedron_t ph,
			   ppl_const_Constraint_System_t* pcs);

/*! \brief
  Writes a const handle to the generator system defining the
  polyhedron \p ph at address \p pgs.
*/
int
ppl_Polyhedron_generators(ppl_const_Polyhedron_t ph,
			  ppl_const_Generator_System_t* pgs);

/*! \brief
  Writes at address \p pcs a const handle to a system of congruences
  approximating the polyhedron \p ph.
*/
int
ppl_Polyhedron_congruences(ppl_const_Polyhedron_t ph,
			   ppl_const_Congruence_System_t* pcs);

/*! \brief
  Writes a const handle to the minimized constraint system defining the
  polyhedron \p ph at address \p pcs.
*/
int
ppl_Polyhedron_minimized_constraints(ppl_const_Polyhedron_t ph,
				     ppl_const_Constraint_System_t* pcs);

/*! \brief
  Writes a const handle to the minimized generator system defining the
  polyhedron \p ph at address \p pgs.
*/
int
ppl_Polyhedron_minimized_generators(ppl_const_Polyhedron_t ph,
				    ppl_const_Generator_System_t* pgs);

/*! \brief
  Writes at address \p pcs a const handle to a system of minimized
  congruences approximating the polyhedron \p ph.
*/
int
ppl_Polyhedron_minimized_congruences(ppl_const_Polyhedron_t ph,
				     ppl_const_Congruence_System_t* pcs);

/*! \brief
  Checks the relation between the polyhedron \p ph and the constraint \p c.

  If successful, returns a non-negative integer that is
  obtained as the bitwise or of the bits (chosen among
  PPL_POLY_CON_RELATION_IS_DISJOINT
  PPL_POLY_CON_RELATION_STRICTLY_INTERSECTS,
  PPL_POLY_CON_RELATION_IS_INCLUDED, and
  PPL_POLY_CON_RELATION_SATURATES) that describe the relation between
  \p ph and \p c.
*/
int
ppl_Polyhedron_relation_with_Constraint(ppl_const_Polyhedron_t ph,
					ppl_const_Constraint_t c);

/*! \brief
  Checks the relation between the polyhedron \p ph and the generator \p g.

  If successful, returns a non-negative integer that is
  obtained as the bitwise or of the bits (only
  PPL_POLY_GEN_RELATION_SUBSUMES, at present) that describe the
  relation between \p ph and \p g.
*/
int
ppl_Polyhedron_relation_with_Generator(ppl_const_Polyhedron_t ph,
				       ppl_const_Generator_t g);

/*! \brief
  Returns a positive integer if \p ph is empty; returns 0 if \p ph is
  not empty.
*/
int
ppl_Polyhedron_is_empty(ppl_const_Polyhedron_t ph);

/*! \brief
  Returns a positive integer if \p ph is a universe polyhedron;
  returns 0 if it is not.
*/
int
ppl_Polyhedron_is_universe(ppl_const_Polyhedron_t ph);

/*! \brief
  Returns a positive integer if \p ph is bounded; returns 0 if \p ph is
  unbounded.
*/
int
ppl_Polyhedron_is_bounded(ppl_const_Polyhedron_t ph);

/*! \brief
  Returns a positive integer if \p ph contains at least one integer
  point; returns 0 otherwise.
*/
int
ppl_Polyhedron_contains_integer_point(ppl_const_Polyhedron_t ph);

/*! \brief
  Returns a positive integer if \p ph is topologically closed;
  returns 0 if \p ph is not topologically closed.
*/
int
ppl_Polyhedron_is_topologically_closed(ppl_const_Polyhedron_t ph);

/*! \brief
  Returns a positive integer if \p ph is a discrete set;
  returns 0 if \p ph is not a discrete set.
*/
int
ppl_Polyhedron_is_discrete(ppl_const_Polyhedron_t ph);

/*! \brief
  Returns a positive integer if \p le is bounded from above in \p ph;
  returns 0 otherwise.
*/
int
ppl_Polyhedron_bounds_from_above(ppl_const_Polyhedron_t ph,
				 ppl_const_Linear_Expression_t le);

/*! \brief
  Returns a positive integer if \p le is bounded from below in \p ph;
  returns 0 otherwise.
*/
int
ppl_Polyhedron_bounds_from_below(ppl_const_Polyhedron_t ph,
				 ppl_const_Linear_Expression_t le);

/*! \brief
  Returns a positive integer if \p ph is not empty
  and \p le is bounded from above in \p ph, in which case
  the supremum value and a point where \p le reaches it are computed.

  \param ph
  The polyhedron constraining \p le;

  \param le
  The linear expression to be maximized subject to \p ph;

  \param sup_n
  Will be assigned the numerator of the supremum value;

  \param sup_d
  Will be assigned the denominator of the supremum value;

  \param pmaximum
  Will store 1 in this location if the supremum is also the maximum,
  will store 0 otherwise;

  \param point
  Will be assigned the point or closure point where \p le reaches the
  extremum value.

  If \p ph is empty or \p le is not bounded from above,
  0 will be returned and \p sup_n, \p sup_d, \p *pmaximum and \p point
  will be left untouched.
*/
int
ppl_Polyhedron_maximize(ppl_const_Polyhedron_t ph,
			ppl_const_Linear_Expression_t le,
			ppl_Coefficient_t sup_n,
			ppl_Coefficient_t sup_d,
			int* pmaximum,
			ppl_Generator_t point);

/*! \brief
  Returns a positive integer if  \p ph is not empty
  and \p le is bounded from below in \p ph, in which case
  the infimum value and a point where \p le reaches it are computed.

  \param ph
  The polyhedron constraining \p le;

  \param le
  The linear expression to be minimized subject to \p ph;

  \param inf_n
  Will be assigned the numerator of the infimum value;

  \param inf_d
  Will be assigned the denominator of the infimum value;

  \param pminimum
  Will store 1 in this location if the infimum is also the minimum,
  will store 0 otherwise;

  \param point
  Will be assigned the point or closure point where \p le reaches the
  extremum value.

  If \p ph is empty or \p le is not bounded from below,
  0 will be returned and \p sup_n, \p sup_d, \p *pmaximum and \p point
  will be left untouched.
*/
int
ppl_Polyhedron_minimize(ppl_const_Polyhedron_t ph,
			ppl_const_Linear_Expression_t le,
			ppl_Coefficient_t inf_n,
			ppl_Coefficient_t inf_d,
			int* pminimum,
			ppl_Generator_t point);

/*! \brief
  Returns a positive integer if \p x contains or is equal to \p y;
  returns 0 if it does not.
*/
int
ppl_Polyhedron_contains_Polyhedron(ppl_const_Polyhedron_t x,
				   ppl_const_Polyhedron_t y);

/*! \brief
  Returns a positive integer if \p x strictly contains \p y; returns 0
  if it does not.
*/
int
ppl_Polyhedron_strictly_contains_Polyhedron(ppl_const_Polyhedron_t x,
					    ppl_const_Polyhedron_t y);

/*! \brief
  Returns a positive integer if \p x and \p y are disjoint; returns 0
  if they are not.
*/
int
ppl_Polyhedron_is_disjoint_from_Polyhedron(ppl_const_Polyhedron_t x,
					   ppl_const_Polyhedron_t y);

/*! \brief
  Returns a positive integer if \p x and \p y are the same polyhedron;
  returns 0 if they are different.

  Note that \p x and \p y may be topology- and/or dimension-incompatible
  polyhedra: in those cases, the value 0 is returned.
*/
int
ppl_Polyhedron_equals_Polyhedron(ppl_const_Polyhedron_t x,
				 ppl_const_Polyhedron_t y);

/*! \brief
  Returns a positive integer if \p ph is well formed, i.e., if it
  satisfies all its implementation invariants; returns 0 and perhaps
  makes some noise if \p ph is broken.  Useful for debugging purposes.
*/
int
ppl_Polyhedron_OK(ppl_const_Polyhedron_t ph);

/*@}*/ /* Functions that Do Not Modify the Polyhedron */


/*! \name Space Dimension Preserving Functions that May Modify the Polyhedron */
/*@{*/

/*! \brief
  Adds a copy of the constraint \p c to the system of constraints of \p ph.
*/
int
ppl_Polyhedron_add_constraint(ppl_Polyhedron_t ph,
			      ppl_const_Constraint_t c);

/*! \brief
  Adds a copy of the constraint \p c to the system of constraints of
  \p ph.  Returns a positive integer if the resulting polyhedron is
  non-empty; returns 0 if it is empty.  Upon successful return, \p ph
  is guaranteed to be minimized.
*/
int
ppl_Polyhedron_add_constraint_and_minimize(ppl_Polyhedron_t ph,
					   ppl_const_Constraint_t c);

/*! \brief
  Adds a copy of the generator \p g to the system of generators of
  \p ph.
*/
int
ppl_Polyhedron_add_generator(ppl_Polyhedron_t ph,
			     ppl_const_Generator_t g);

/*! \brief
  Adds a copy of the generator \p g to the system of generators of
  \p ph.  Returns a positive integer if the resulting polyhedron is
  non-empty; returns 0 if it is empty.  Upon successful return, \p ph
  is guaranteed to be minimized.
*/
int
ppl_Polyhedron_add_generator_and_minimize(ppl_Polyhedron_t ph,
					  ppl_const_Generator_t g);

/*! \brief
  Adds a copy of the system of constraints \p cs to the system of
  constraints of \p ph.
*/
int
ppl_Polyhedron_add_constraints(ppl_Polyhedron_t ph,
			       ppl_const_Constraint_System_t cs);

/*! \brief
  Adds a copy of the system of constraints \p cs to the system of
  constraints of \p ph.  Returns a positive integer if the resulting
  polyhedron is non-empty; returns 0 if it is empty.  Upon successful
  return, \p ph is guaranteed to be minimized.
*/
int
ppl_Polyhedron_add_constraints_and_minimize(ppl_Polyhedron_t ph,
					    ppl_const_Constraint_System_t cs);

/*! \brief
  Adds a copy of the system of generators \p gs to the system of
  generators of \p ph.
*/
int
ppl_Polyhedron_add_generators(ppl_Polyhedron_t ph,
			      ppl_const_Generator_System_t gs);

/*! \brief
  Adds a copy of the system of generators \p gs to the system of
  generators of \p ph.  Returns a positive integer if the resulting
  polyhedron is non-empty; returns 0 if it is empty.  Upon successful
  return, \p ph is guaranteed to be minimized.
*/
int
ppl_Polyhedron_add_generators_and_minimize(ppl_Polyhedron_t ph,
					   ppl_const_Generator_System_t gs);

/*! \brief
  Adds the system of constraints \p cs to the system of constraints of
  \p ph.

  \warning
  This function modifies the constraint system referenced by \p cs:
  upon return, no assumption can be made on its value.
*/
int
ppl_Polyhedron_add_recycled_constraints(ppl_Polyhedron_t ph,
					ppl_Constraint_System_t cs);

/*! \brief
  Adds the system of constraints \p cs to the system of constraints of
  \p ph.  Returns a positive integer if the resulting polyhedron is
  non-empty; returns 0 if it is empty.  Upon successful return, \p ph
  is guaranteed to be minimized.

  \warning
  This function modifies the constraint system referenced by \p cs:
  upon return, no assumption can be made on its value.
*/
int
ppl_Polyhedron_add_recycled_constraints_and_minimize
(ppl_Polyhedron_t ph, ppl_Constraint_System_t cs);

/*! \brief
  Adds the system of generators \p gs to the system of generators of
  \p ph.

  \warning
  This function modifies the generator system referenced by \p gs:
  upon return, no assumption can be made on its value.
*/
int
ppl_Polyhedron_add_recycled_generators(ppl_Polyhedron_t ph,
				       ppl_Generator_System_t gs);

/*! \brief
  Adds the system of generators \p gs to the system of generators of
  \p ph.  Returns a positive integer if the resulting polyhedron is
  non-empty; returns 0 if it is empty.  Upon successful return, \p ph
  is guaranteed to be minimized.

  \warning
  This function modifies the generator system referenced by \p gs:
  upon return, no assumption can be made on its value.
*/
int
ppl_Polyhedron_add_recycled_generators_and_minimize(ppl_Polyhedron_t ph,
						    ppl_Generator_System_t gs);

/*! \brief
  Intersects \p x with polyhedron \p y and assigns the result to \p x.
*/
int
ppl_Polyhedron_intersection_assign(ppl_Polyhedron_t x,
				   ppl_const_Polyhedron_t y);

/*! \brief
  Assigns to \p x the poly-hull of \p x and \p y.
*/
int
ppl_Polyhedron_poly_hull_assign(ppl_Polyhedron_t x,
				ppl_const_Polyhedron_t y);

/*! \brief
  Same as ppl_Polyhedron_poly_hull_assign(x, y).
*/
int
ppl_Polyhedron_upper_bound_assign(ppl_Polyhedron_t x,
				  ppl_const_Polyhedron_t y);

/*! \brief
  Assigns to \p x the \extref{Convex_Polyhedral_Difference, poly-difference}
  of \p x and \p y.
*/
int
ppl_Polyhedron_poly_difference_assign(ppl_Polyhedron_t x,
				      ppl_const_Polyhedron_t y);

/*! \brief
  Same as ppl_Polyhedron_poly_difference_assign(x, y).
*/
int
ppl_Polyhedron_difference_assign(ppl_Polyhedron_t x,
				 ppl_const_Polyhedron_t y);
/*! \brief
   Assigns to \p x a meet preserving enlargement and simplification of \p y.
*/
int
ppl_Polyhedron_simplify_using_context_assign(ppl_Polyhedron_t x,
				  ppl_const_Polyhedron_t y);

/*! \brief
  Assigns to \p x the \extref{Time_Elapse_Operator, time-elapse} between
  the polyhedra \p x and \p y.
*/
int
ppl_Polyhedron_time_elapse_assign(ppl_Polyhedron_t x,
				  ppl_const_Polyhedron_t y);

/*! \brief
  Assigns to \p ph its topological closure.
*/
int
ppl_Polyhedron_topological_closure_assign(ppl_Polyhedron_t ph);

/*! \brief
  Transforms the polyhedron \p ph, assigning an affine expression
  to the specified variable.

  \param ph
  The polyhedron that is transformed;

  \param var
  The variable to which the affine expression is assigned;

  \param le
  The numerator of the affine expression;

  \param d
  The denominator of the affine expression.
*/
int
ppl_Polyhedron_affine_image(ppl_Polyhedron_t ph,
			    ppl_dimension_type var,
			    ppl_const_Linear_Expression_t le,
			    ppl_const_Coefficient_t d);

/*! \brief
  Transforms the polyhedron \p ph, substituting an affine expression
  to the specified variable.

  \param ph
  The polyhedron that is transformed;

  \param var
  The variable to which the affine expression is substituted;

  \param le
  The numerator of the affine expression;

  \param d
  The denominator of the affine expression.
*/
int
ppl_Polyhedron_affine_preimage(ppl_Polyhedron_t ph,
			       ppl_dimension_type var,
			       ppl_const_Linear_Expression_t le,
			       ppl_const_Coefficient_t d);

/*! \brief
  Assigns to \p ph the image of \p ph with respect to the
  \extref{Generalized_Affine_Relations, generalized affine transfer relation}
  \f$\frac{\mathrm{lb}}{\mathrm{d}}
       \leq \mathrm{var}'
         \leq \frac{\mathrm{ub}}{\mathrm{d}}\f$.

  \param ph
  The polyhedron that is transformed;

  \param var
  The variable bounded by the generalized affine transfer relation;

  \param lb
  The numerator of the lower bounding affine expression;

  \param ub
  The numerator of the upper bounding affine expression;

  \param d
  The (common) denominator of the lower and upper bounding affine expressions.
*/
int
ppl_Polyhedron_bounded_affine_image(ppl_Polyhedron_t ph,
				    ppl_dimension_type var,
				    ppl_const_Linear_Expression_t lb,
				    ppl_const_Linear_Expression_t ub,
				    ppl_const_Coefficient_t d);

/*! \brief
  Assigns to \p ph the preimage of \p ph with respect to the
  \extref{Generalized_Affine_Relations, generalized affine transfer relation}
  \f$\frac{\mathrm{lb}}{\mathrm{d}}
       \leq \mathrm{var}'
         \leq \frac{\mathrm{ub}}{\mathrm{d}}\f$.

  \param ph
  The polyhedron that is transformed;

  \param var
  The variable bounded by the generalized affine transfer relation;

  \param lb
  The numerator of the lower bounding affine expression;

  \param ub
  The numerator of the upper bounding affine expression;

  \param d
  The (common) denominator of the lower and upper bounding affine expressions.
*/
int
ppl_Polyhedron_bounded_affine_preimage(ppl_Polyhedron_t ph,
				       ppl_dimension_type var,
				       ppl_const_Linear_Expression_t lb,
				       ppl_const_Linear_Expression_t ub,
				       ppl_const_Coefficient_t d);

/*! \brief
  Assigns to \p ph the image of \p ph with respect to the
  \extref{Generalized_Affine_Relations, generalized affine transfer relation}
  \f$\mathrm{var}' \relsym \frac{\mathrm{le}}{\mathrm{d}}\f$,
  where \f$\mathord{\relsym}\f$ is the relation symbol encoded
  by \p relsym.

  \param ph
  The polyhedron that is transformed;

  \param var
  The left hand side variable of the generalized affine transfer relation;

  \param relsym
  The relation symbol;

  \param le
  The numerator of the right hand side affine expression;

  \param d
  The denominator of the right hand side affine expression.
*/
int
ppl_Polyhedron_generalized_affine_image(ppl_Polyhedron_t ph,
					ppl_dimension_type var,
					enum ppl_enum_Constraint_Type relsym,
					ppl_const_Linear_Expression_t le,
					ppl_const_Coefficient_t d);

/*! \brief
  Assigns to \p ph the preimage of \p ph with respect to the
  \extref{Generalized_Affine_Relations, generalized affine transfer relation}
  \f$\mathrm{var}' \relsym \frac{\mathrm{le}}{\mathrm{d}}\f$,
  where \f$\mathord{\relsym}\f$ is the relation symbol encoded
  by \p relsym.

  \param ph
  The polyhedron that is transformed;

  \param var
  The left hand side variable of the generalized affine transfer relation;

  \param relsym
  The relation symbol;

  \param le
  The numerator of the right hand side affine expression;

  \param d
  The denominator of the right hand side affine expression.
*/
int
ppl_Polyhedron_generalized_affine_preimage
(ppl_Polyhedron_t ph,
 ppl_dimension_type var,
 enum ppl_enum_Constraint_Type relsym,
 ppl_const_Linear_Expression_t le,
 ppl_const_Coefficient_t d);

/*! \brief
  Assigns to \p ph the image of \p ph with respect to the
  \extref{Generalized_Affine_Relations, generalized affine transfer relation}
  \f$\mathrm{lhs}' \relsym \mathrm{rhs}\f$, where
  \f$\mathord{\relsym}\f$ is the relation symbol encoded by \p relsym.

  \param ph
  The polyhedron that is transformed;

  \param lhs
  The left hand side affine expression;

  \param relsym
  The relation symbol;

  \param rhs
  The right hand side affine expression.
*/
int
ppl_Polyhedron_generalized_affine_image_lhs_rhs
(ppl_Polyhedron_t ph,
 ppl_const_Linear_Expression_t lhs,
 enum ppl_enum_Constraint_Type relsym,
 ppl_const_Linear_Expression_t rhs);

/*! \brief
  Assigns to \p ph the preimage of \p ph with respect to the
  \extref{Generalized_Affine_Relations, generalized affine transfer relation}
  \f$\mathrm{lhs}' \relsym \mathrm{rhs}\f$, where
  \f$\mathord{\relsym}\f$ is the relation symbol encoded by \p relsym.

  \param ph
  The polyhedron that is transformed;

  \param lhs
  The left hand side affine expression;

  \param relsym
  The relation symbol;

  \param rhs
  The right hand side affine expression.
*/
int
ppl_Polyhedron_generalized_affine_preimage_lhs_rhs
(ppl_Polyhedron_t ph,
 ppl_const_Linear_Expression_t lhs,
 enum ppl_enum_Constraint_Type relsym,
 ppl_const_Linear_Expression_t rhs);

/*! \brief
  If the polyhedron \p y is contained in (or equal to) the polyhedron
  \p x, assigns to \p x the \extref{BHRZ03_widening, BHRZ03-widening} of
  \p x and \p y.  If \p tp is not the null pointer, the
  \extref{Widening_with_Tokens, widening with tokens} delay technique
  is applied with <CODE>*tp</CODE> available tokens.
*/
int
ppl_Polyhedron_BHRZ03_widening_assign_with_tokens
(ppl_Polyhedron_t x,
 ppl_const_Polyhedron_t y,
 unsigned* tp);

/*! \brief
  If the polyhedron \p y is contained in (or equal to) the polyhedron
  \p x, assigns to \p x the \extref{H79_widening, H79-widening} of \p x
  and \p y.  If \p tp is not the null pointer, the
  \extref{Widening_with_Tokens, widening with tokens} delay technique is
  applied with <CODE>*tp</CODE> available tokens.
*/
int
ppl_Polyhedron_H79_widening_assign_with_tokens
(ppl_Polyhedron_t x,
 ppl_const_Polyhedron_t y,
 unsigned* tp);

/*! \brief
  If the polyhedron \p y is contained in (or equal to) the polyhedron
  \p x, assigns to \p x the \extref{BHRZ03_widening, BHRZ03-widening} of
  \p x and \p y.
*/
int
ppl_Polyhedron_BHRZ03_widening_assign(ppl_Polyhedron_t x,
				      ppl_const_Polyhedron_t y);

/*! \brief
  If the polyhedron \p y is contained in (or equal to) the polyhedron
  \p x, assigns to \p x the \extref{H79_widening, H79-widening} of \p x
  and \p y.
*/
int
ppl_Polyhedron_H79_widening_assign(ppl_Polyhedron_t x,
				   ppl_const_Polyhedron_t y);

/*! \brief
  If the polyhedron \p y is contained in (or equal to) the polyhedron
  \p x, assigns to \p x the \extref{BHRZ03_widening, BHRZ03-widening} of
  \p x and \p y intersected with the constraints in \p cs that are
  satisfied by all the points of \p x.  If \p tp is not the null pointer,
  the \extref{Widening_with_Tokens, widening with tokens} delay technique
  is applied with <CODE>*tp</CODE> available tokens.
*/
int
ppl_Polyhedron_limited_BHRZ03_extrapolation_assign_with_tokens
(ppl_Polyhedron_t x,
 ppl_const_Polyhedron_t y,
 ppl_const_Constraint_System_t cs,
 unsigned* tp);

/*! \brief
  If the polyhedron \p y is contained in (or equal to) the polyhedron
  \p x, assigns to \p x the \extref{H79_widening, H79-widening} of \p x
  and \p y intersected with the constraints in \p cs that are
  satisfied by all the points of \p x. If \p tp is not the null
  pointer, the \extref{Widening_with_Tokens, widening with tokens} delay
  technique is applied with <CODE>*tp</CODE> available tokens.
*/
int
ppl_Polyhedron_limited_H79_extrapolation_assign_with_tokens
(ppl_Polyhedron_t x,
 ppl_const_Polyhedron_t y,
 ppl_const_Constraint_System_t cs,
 unsigned* tp);

/*! \brief
  If the polyhedron \p y is contained in (or equal to) the polyhedron
  \p x, assigns to \p x the \extref{BHRZ03_widening, BHRZ03-widening} of
  \p x and \p y intersected with the constraints in \p cs that are
  satisfied by all the points of \p x.
*/
int
ppl_Polyhedron_limited_BHRZ03_extrapolation_assign
(ppl_Polyhedron_t x,
 ppl_const_Polyhedron_t y,
 ppl_const_Constraint_System_t cs);

/*! \brief
  If the polyhedron \p y is contained in (or equal to) the polyhedron
  \p x, assigns to \p x the \extref{H79_widening, H79-widening} of \p x
  and \p y intersected with the constraints in \p cs that are
  satisfied by all the points of \p x.
*/
int
ppl_Polyhedron_limited_H79_extrapolation_assign
(ppl_Polyhedron_t x,
 ppl_const_Polyhedron_t y,
 ppl_const_Constraint_System_t cs);

/*! \brief
  If the polyhedron \p y is contained in (or equal to) the polyhedron
  \p x, assigns to \p x the \extref{BHRZ03_widening, BHRZ03-widening} of
  \p x and \p y intersected with the constraints in \p cs that are
  satisfied by all the points of \p x, further intersected with all
  the constraints of the form \f$\pm v \leq r\f$ and \f$\pm v < r\f$,
  with \f$r \in \Qset\f$, that are satisfied by all the points of \p
  x. If \p tp is not the null pointer,
  the \extref{Widening_with_Tokens, widening with tokens} delay technique
  is applied with <CODE>*tp</CODE> available tokens.
*/
int
ppl_Polyhedron_bounded_BHRZ03_extrapolation_assign_with_tokens
(ppl_Polyhedron_t x,
 ppl_const_Polyhedron_t y,
 ppl_const_Constraint_System_t cs,
 unsigned* tp);

/*! \brief
  If the polyhedron \p y is contained in (or equal to) the polyhedron
  \p x, assigns to \p x the \extref{H79_widening, H79-widening} of \p x
  and \p y intersected with the constraints in \p cs that are
  satisfied by all the points of \p x, further intersected with all
  the constraints of the form \f$\pm v \leq r\f$ and \f$\pm v < r\f$,
  with \f$r \in \Qset\f$, that are satisfied by all the points of \p x.
  If \p tp is not the null pointer,
  the \extref{Widening_with_Tokens, widening with tokens} delay technique
  is applied with <CODE>*tp</CODE> available tokens.
*/
int
ppl_Polyhedron_bounded_H79_extrapolation_assign_with_tokens
(ppl_Polyhedron_t x,
 ppl_const_Polyhedron_t y,
 ppl_const_Constraint_System_t cs,
 unsigned* tp);

/*! \brief
  If the polyhedron \p y is contained in (or equal to) the polyhedron
  \p x, assigns to \p x the \extref{BHRZ03_widening, BHRZ03-widening} of
  \p x and \p y intersected with the constraints in \p cs that are
  satisfied by all the points of \p x, further intersected with all
  the constraints of the form \f$\pm v \leq r\f$ and \f$\pm v < r\f$,
  with \f$r \in \Qset\f$, that are satisfied by all the points of \p x.
*/
int
ppl_Polyhedron_bounded_BHRZ03_extrapolation_assign
(ppl_Polyhedron_t x,
 ppl_const_Polyhedron_t y,
 ppl_const_Constraint_System_t cs);

/*! \brief
  If the polyhedron \p y is contained in (or equal to) the polyhedron
  \p x, assigns to \p x the \extref{H79_widening, H79-widening} of \p x
  and \p y intersected with the constraints in \p cs that are
  satisfied by all the points of \p x, further intersected with all
  the constraints of the form \f$\pm v \leq r\f$ and \f$\pm v < r\f$,
  with \f$r \in \Qset\f$, that are satisfied by all the points of \p
  x.
*/
int
ppl_Polyhedron_bounded_H79_extrapolation_assign
(ppl_Polyhedron_t x,
 ppl_const_Polyhedron_t y,
 ppl_const_Constraint_System_t cs);

/*@}*/ /* Space Dimension Preserving Functions that May Modify [...] */


/*! \name Functions that May Modify the Dimension of the Vector Space */
/*@{*/

/*! \brief
  Seeing a polyhedron as a set of tuples (its points), assigns
  to \p x all the tuples that can be obtained by concatenating,
  in the order given, a tuple of \p x with a tuple of \p y.
*/
int
ppl_Polyhedron_concatenate_assign(ppl_Polyhedron_t x,
				  ppl_const_Polyhedron_t y);

/*! \brief
  Adds \p d new dimensions to the space enclosing the polyhedron \p ph
  and to \p ph itself.
*/
int
ppl_Polyhedron_add_space_dimensions_and_embed(ppl_Polyhedron_t ph,
					      ppl_dimension_type d);

/*! \brief
  Adds \p d new dimensions to the space enclosing the polyhedron \p ph.
*/
int
ppl_Polyhedron_add_space_dimensions_and_project(ppl_Polyhedron_t ph,
						ppl_dimension_type d);

/*! \brief
  Removes from the vector space enclosing \p ph the space dimensions that
  are specified in first \p n positions of the array \p ds.  The presence
  of duplicates in \p ds is a waste but an innocuous one.
*/
int
ppl_Polyhedron_remove_space_dimensions(ppl_Polyhedron_t ph,
				       ppl_dimension_type ds[],
				       size_t n);

/*! \brief
  Removes the higher dimensions from the vector space enclosing \p ph
  so that, upon successful return, the new space dimension is \p d.
*/
int
ppl_Polyhedron_remove_higher_space_dimensions(ppl_Polyhedron_t ph,
					      ppl_dimension_type d);

/*! \brief
  Remaps the dimensions of the vector space according to a
  \extref{Mapping_the_Dimensions_of_the_Vector_Space, partial function}.
  This function is specified by means of the \p maps array,
  which has \p n entries.

  The partial function is defined on dimension <CODE>i</CODE>
  if <CODE>i < n</CODE> and <CODE>maps[i] != ppl_not_a_dimension</CODE>;
  otherwise it is undefined on dimension <CODE>i</CODE>.
  If the function is defined on dimension <CODE>i</CODE>, then dimension
  <CODE>i</CODE> is mapped onto dimension <CODE>maps[i]</CODE>.

  The result is undefined if \p maps does not encode a partial
  function with the properties described in the
  \extref{Mapping_the_Dimensions_of_the_Vector_Space,
          specification of the mapping operator}.
*/
int
ppl_Polyhedron_map_space_dimensions(ppl_Polyhedron_t ph,
				    ppl_dimension_type maps[],
				    size_t n);

/*! \brief
  \extref{expand_space_dimension, Expands} the \f$d\f$-th dimension of
  the vector space enclosing \p ph to \p m new space dimensions.
*/
int
ppl_Polyhedron_expand_space_dimension(ppl_Polyhedron_t ph,
				      ppl_dimension_type d,
				      ppl_dimension_type m);

/*! \brief
  Modifies \p ph by \extref{fold_space_dimensions, folding} the
  space dimensions contained in the first \p n positions of the array \p ds
  into dimension \p d.  The presence of duplicates in \p ds is a waste
  but an innocuous one.
*/
int
ppl_Polyhedron_fold_space_dimensions(ppl_Polyhedron_t ph,
				     ppl_dimension_type ds[],
				     size_t n,
				     ppl_dimension_type d);

/*@}*/ /* Functions that May Modify the Dimension of the Vector Space */


/*! \name Output Functions */
/*@{*/

/*! \brief Prints \p x to <CODE>stdout</CODE>. */
int
ppl_io_print_Polyhedron(ppl_const_Polyhedron_t x);

/*! \brief Prints \p x to the given output \p stream. */
int
ppl_io_fprint_Polyhedron(FILE* stream, ppl_const_Polyhedron_t x);

/*! \brief Dumps an ascii representation of \p x on \p stream. */
int
ppl_Polyhedron_ascii_dump(ppl_const_Polyhedron_t x, FILE* stream);

/*@}*/ /* Output Functions */

/*@}*/ /* \defgroup Polyhedron */
