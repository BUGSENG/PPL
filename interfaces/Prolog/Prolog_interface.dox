/* Documentation for the Prolog interfaces.
   Copyright (C) 2001, 2002 Roberto Bagnara <bagnara@cs.unipr.it>

This file is part of the Parma Polyhedra Library (PPL).

The PPL is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at your
option) any later version.

The PPL is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
USA.

For the most up-to-date information see the Parma Polyhedra Library
site: http://www.cs.unipr.it/ppl/ . */

/*! \page Prolog_Interface Prolog Interface


\subsection PI_Intro Introduction

This Prolog library is an interface to the PPL and
provides Prolog operations for creating and
manipulating the PPL polyhedra.

In the sequel, <CODE>prefix</CODE> is the prefix under which
you have installed the library (typically <CODE>/usr</CODE>
or <CODE>/usr/local</CODE>).

\subsection Compiling the Interfaces

When the Parma Polyhedra Library is configured, it tests for the existence
of each supported Prolog system.  If a supported Prolog system is
correctly installed in a standard location, things are arranged
so that the corresponding interface is built and installed.

As an option, the Prolog interfaces can track the creation and disposal
of polyhedra.  In fact, differently from native Prolog data, PPL polyhedra
must be explicitely disposed and forgetting to do so is a very common mistake.
To enable this option, configure the library adding
<CODE>-DTRACK_ALLOCATION</CODE> to the options passed to the C++ compiler.
Your configure command would then look like
\code
  path/to/configure --with-cxxflags="-DTRACK_ALLOCATION" ...
\endcode

\subsection PI_SD_Features System-Dependent Features

<H4>CIAO Prolog</H4>

Support for CIAO Prolog is under development and will be available in 
 a future release. 

<H4>GNU Prolog</H4>



<H4>SICStus Prolog</H4>

The SICStus Prolog interface of the library provides is available
both as a statically linked module or as a dynamically linked one.
Only SICStus Prolog version 3.9.0 or later is supported.

<H5>The Statically Linked <CODE>ppl_sicstus</CODE> Executable</H5>

If an appropriate version of SICStus Prolog is installed on the machine
on which you compiled the library, the command <CODE>make install</CODE>
will install the executable <CODE>ppl_sicstus</CODE> in the directory
<CODE>prefix/bin</CODE>.
The <CODE>ppl_sicstus</CODE> executable is simply the SICStus Prolog
system with the Parma Polyhedra library statically linked.
The only thing you should do to use the library is to
load <CODE>prefix/lib/ppl/ppl_sicstus.pl</CODE>.

<H5>Dynamic Linking</H5>

In order to dynamically load the library from SICStus Prolog you should
simply load <CODE>prefix/lib/ppl/ppl_sicstus.pl</CODE>.
Notice that, for dynamic linking to work, you should have configured
the library with the <CODE>--enable-shared</CODE> option.


<H4>SWI-Prolog</H4>

The SWI-Prolog interface of the library provides is available
both as a statically linked module or as a dynamically linked one.
Only SWI-Prolog version 5.0 or later is supported.

<H5>The Statically Linked <CODE>ppl_pl</CODE> Executable</H5>

If an appropriate version of SWI-Prolog is installed on the machine
on which you compiled the library, the command <CODE>make install</CODE>
will install the executable <CODE>ppl_pl</CODE> in the directory
<CODE>prefix/bin</CODE>.
The <CODE>ppl_pl</CODE> executable is simply the SWI-Prolog
system with the Parma Polyhedra library statically linked:
from within <CODE>ppl_pl</CODE> all the services of the library
are available without further action.

<H5>Dynamic Linking</H5>

In order to dynamically load the library from SWI-Prolog you should
simply execute
\code
  load_foreign_library('prefix/lib/ppl/libppl_swiprolog').
\endcode
Notice that, for dynamic linking to work, you should have configured
the library with the <CODE>--enable-shared</CODE> option.

 
<H4>YAP</H4>



\subsection PI_SI_Features System-Independent Features

The Prolog interface provides access to the PPL polyhedra
which can have one of two topologies: <EM>closed (C)</EM>,
in which case all the constraints
defining the polyhedron must be equalities or non-strict inequalities
and its generators must be points, rays or lines;
or <EM>not necessarily closed (NNC)</EM>,
where the constraints defining the polyhedron may
include strict inequalities and
the generators can include closure points.

The PPL predicates provided  for the Prolog interface are specified below.

The specification uses the following grammar rules:
\code
 Topology  --> c | nnc			

 VarId     --> non-negative integer	variable identifier

 PPL_Var   --> '$VAR'(VarId) 	 	PPL variable

 LinExpr   --> PPL_Var              	PPL variable
          | number               	integer
          | + LinExpr            	unary plus
          | - LinExpr            	unary minus
          | LinExpr + LinExpr    	addition
          | LinExpr - LinExpr    	subtraction
          | number * LinExpr     	multiplication
          | LinExpr * number     	multiplication

 Constraint --> LinExpr = LinExpr   	equation
          | LinExpr =< LinExpr 		nonstrict inequation
          | LinExpr >= LinExpr 		nonstrict inequation
          | LinExpr < LinExpr  		strict inequation
          | LinExpr > LinExpr  		strict inequation

 Generator --> point(LinExpr)        	point
          | point(LinExpr, number)   	point
          | closure-point(LinExpr)  	closure point
          | closure-point(LinExpr, number)
				 	closure point
              (Int is the denominator so that the point or 
               closure point is defined by Expr/Int.)
          | ray(LinExpr)         	ray
          | line(LinExpr)        	line

 Interval  --> i(Bound, Bound)		rational interval

 Bound     --> c(Rational)		closed rational limit
          | o(Rational)			open rational limit
          | o(pinf)			unbounded in the positive direction
          | o(minf)			unbounded in the negative direction

 Rational  --> number | number/number	rational number
\endcode


We first give some general information about the Prolog interface
to the PPL library.

-  Access to any PPL polyhedron is provided by means of a Prolog term
   called a <EM>handle</EM>.
   The data structure of a handle,
   is implementation-dependent, system-dependent and
   version-dependent, and, for this reason, deliberately left unspecified.
   What we do guarantee is that a handle is an ordinary Prolog term
   that can be used as such and requiring very little memory.

-  Only terms bound to <EM>valid</EM> handles may be used to access
   PPL polyhedra.
   A handle is made valid by using:
\code  
   ppl_new_Polyhedron_from_dimension/3, 
   ppl_new_Polyhedron_empty_from_dimension/3,
   ppl_new_Polyhedron_from_Polyhedron/4,
   ppl_new_Polyhedron_from_ConSys/3,
   ppl_new_Polyhedron_from_GenSys/3.
\endcode
   These predicates will create or copy a PPL polyhedron
   and construct a valid handle for referencing it.
   The first argument
   (in the case of <CODE>ppl_new_Polyhedron_from_Polyhedron/4</CODE>,
   the first and third arguments) denotes the topology
   and can be either <CODE>c</CODE> or <CODE>nnc</CODE>
   indicating a C or NNC polyhedron, respectively.
   The third argument
   (in the case of <CODE>ppl_new_Polyhedron_from_Polyhedron/4</CODE>,
   the fourth argument) is a Prolog term that is
   unified with a new valid handle for accessing this polyhedron.

- As soon as a PPL polyhedron is no longer required,
  the memory occupied by it should be released
  using the PPL predicate <CODE>ppl_delete_Polyhedron/1</CODE>.
  To understand why this is important,
  consider a Prolog program and a variable that is bound to
  a Herbrand term.
  When the variable dies (goes out of scope) or is uninstantiated
  (on backtracking) the term it is bound to is amenable to garbage collection.
  But this only applies for the standard domain of the language:
  Herbrand terms.
  In Prolog+PPL, when a variable bound to a handle for a PPL Polyhedron dies
  or is uninstantiated,
  the handle can be garbage-collected, but the polyhedra to which
  the handle refers will not be released.
  Once a handle has been used as an argument in 
  <CODE>ppl_delete_Polyhedron/1</CODE>,
  it becomes invalid.
  
- For a PPL polyhedron with space dimension \p k,
  the identifiers used for the PPL variables in
  the constraints and the generators
  must lie between 0 and \f$k-1\f$.
  Moreover, when using the predicates that combine PPL polyhedra
  or add constraints or generators to a representation of
  a PPL polyhedron,
  the polyhedra referenced and any constraints or generators in the call
  should follow all the rules stated in the dimension-compatibility
  paragraph in the Introduction.

- As explained above, a polyhedron has a fixed topology C or NNC,
  that is determined at the time of its initialization.
  This must be respected in all subsequent operations on the polyhedron.
  This means that whenever constraints are added to a
  C Polyhedron, then only constraints that are equalities or non-strict
  inequalities can be added to a C Polyhedron.
  Similarly, only generators that are points, rays or lines can be added
  to a C Polyhedron.
  In addition, only polyhedra that have the same topology may be compared.

- There are a number of predicates whose name ends with
  <CODE>_and_minimize</CODE>.
  These are provided to help the user obtain better performance.<BR>
  For some of the operations on polyhedra in the PPL,
  the internal representation of a polyhedra has to be <EM>minimized</EM>:
  if it is not already minimized,
  an extra PPL minimization operation is performed first.
  However this operation may be very costly
  and, for this reason, the PPL library is lazy and avoids
  it as much as it can.
  For this reason, a predicate without <CODE>_and_minimize</CODE> ending
  should be used
  unless a minimized representation is needed for the next PPL operation.
  In that case it is more efficient to use
  the <CODE>_and_minimize</CODE> predicate.
  As an example, suppose you have to compute the poly-hull of several
  polyhedra. Then use the
  <CODE>ppl_Polyhedron_poly_hull_assign/2</CODE>
  for each intermediate step and
  <CODE>ppl_Polyhedron_poly_hull_assign_and_minimize/2</CODE>
  for the last step.
  If you just have  to compute the poly-hull of two polyhedra, then use
  <CODE>ppl_Polyhedron_poly_hull_assign_and_minimize/2</CODE>.

See the specifications of individual predicates for examples and
more information regarding these issues.

<H4><CODE>
  ppl_new_Polyhedron_from_dimension(+Topology, +Integer, -Handle)
</CODE></H4>

   Creates a new universe C or NNC polyhedron \f$P\f$,
   depending on the value of <CODE>Topology</CODE>,
   with <CODE>Integer</CODE> dimensions.
   <CODE>Handle</CODE> is unified with the handle for \f$P\f$.
   Thus the query
\code
   ?- ppl_new_Polyhedron_from_dimension(c, X, 3).
\endcode
   creates the C polyhedron defining the 3-dimensional vector space
   \f$\Rset^3\f$ with \p X bound to a valid handle for accessing it.

<H4><CODE>
  ppl_new_Polyhedron_empty_from_dimension(+Topology, +Integer, -Handle)
</CODE>
</H4>

   Creates a new empty C or NNC polyhedron \f$P\f$,
   depending on the value of <CODE>Topology</CODE>,
   with <CODE>Integer</CODE> dimensions.
   <CODE>Handle</CODE> is unified with the handle for \f$P\f$.
   Thus the query
\code
   ?- ppl_new_Polyhedron_empty_from_dimension(nnc, X, 3).
\endcode
   creates an empty NNC polyhedron embedded in \f$\Rset^3\f$ with
   \p X bound to a valid handle for accessing it.

<H4>
   <CODE>ppl_new_Polyhedron_from_Polyhedron(+Topology_1, +Handle_1,
                                   +Topology_2, -Handle_2)</CODE>
</H4>

   If <CODE>Handle_1</CODE> refers to a C or NNC polyhedron \f$P_1\f$
   (depending on the value of <CODE>Topology_1</CODE>),
   then a copy \f$P_2\f$ of \f$P_1\f$ is created
   with topology C or NNC,
   depending on the value of <CODE>Topology_2</CODE>,
   and <CODE>Handle_2</CODE> is unified with the handle for \f$P_2\f$.
   Thus the query
\code
   ?- ppl_new_Polyhedron_empty_from_dimension(nnc, X, 3),
      ppl_new_Polyhedron_from_Polyhedron(c, X, nnc, Y).
\endcode
   creates an empty C polyhedron embedded in \f$\Rset^3\f$
   referenced by \p X
   and then makes a copy, converting the topology to an NNC polyhedron.
   with \p Y bound to a valid handle for accessing it.

   When using <CODE>ppl_new_Polyhedron_from_Polyhedron/2</CODE>,
   when the source polyhedron is NNC and the copy is C,
   care must be taken that the source polyhedron referenced by
   <CODE>Handle1</CODE> can be defined by equality and non-strict
   inequality constraints or (equivalently) its generators are points,
   rays and lines.

<H4>
   <CODE>ppl_new_Polyhedron_from_ConSys(+Topology,
                   +List_of_Constraints, -Handle)</CODE>
</H4>

   A polyhedron \f$P\f$ represented by <CODE>List_of_Constraints</CODE>
   is created with topology C or NNC,
   depending on the value of <CODE>Topology</CODE>,
   and <CODE>Handle</CODE> is unified with the handle for \f$P\f$.

<H4>
   <CODE>ppl_new_Polyhedron_from_GenSys(+Topology
                   +List_of_Generators, -Handle)</CODE>
</H4>

   A polyhedron \f$P\f$ represented by <CODE>List_of_Generators</CODE>
   is created with topology C or NNC,
   depending on the value of <CODE>Topology</CODE>,
   and <CODE>Handle</CODE> is unified with the handle for \f$P\f$.

<H4><CODE>ppl_delete_Polyhedron(+Handle)</CODE></H4>

   Deletes the polyhedron referenced by <CODE>Handle</CODE>.
   After execution,
   <CODE>Handle</CODE> is no longer a valid handle for a PPL polyhedron.

<H4><CODE>ppl_Polyhedron_space_dimension(+Handle, -Integer)</CODE></H4>

   If \f$P\f$ is the polyhedron referenced by <CODE>Handle</CODE>,
   it unifies the space dimension of \f$P\f$ with <CODE>Integer</CODE>.

<H4><CODE>ppl_Polyhedron_intersection_assign(+Handle_1, +Handle_2)</CODE></H4>

   Computes the intersection \f$P\f$ of the polyhedra referenced by
   <CODE>Handle_1</CODE> and <CODE>Handle_2</CODE>.
   After execution, <CODE>Handle_1</CODE> refers to \f$P\f$.

<H4><CODE>ppl_Polyhedron_intersection_assign_and_minimize(+Handle_1,
                     +Handle_2)</CODE></H4>

   Computes the intersection \f$P\f$ of the polyhedra referenced by
   <CODE>Handle_1</CODE> and <CODE>Handle_2</CODE>.
   After execution, <CODE>Handle_1</CODE> refers to \f$P\f$.


<H4><CODE>ppl_Polyhedron_poly_hull_assign(+Handle_1, +Handle_2)</CODE></H4>

   Computes the poly-hull \f$P\f$ of the polyhedra referenced by
   <CODE>Handle_1</CODE> and <CODE>Handle_2</CODE>.
   After execution, <CODE>Handle_1</CODE> refers to \f$P\f$.

<H4><CODE>ppl_Polyhedron_poly_hull_assign_and_minimize(+Handle_1,
               +Handle_2)</CODE></H4>

   Computes the poly-hull \f$P\f$ of the polyhedra referenced by
   <CODE>Handle_1</CODE> and <CODE>Handle_2</CODE>.
   After execution, <CODE>Handle_1</CODE> refers to \f$P\f$.

<H4><CODE>ppl_Polyhedron_poly_difference_assign(+Handle_1, +Handle_2)</CODE></H4>

   Computes the poly-hull \f$P\f$ of the set-theoretic difference of
   the polyhedra referenced by
   <CODE>Handle_1</CODE> and <CODE>Handle_2</CODE>.
   After execution, <CODE>Handle_1</CODE> refers to \f$P\f$.

<H4><CODE>ppl_Polyhedron_poly_difference_assign_and_minimize(+Handle_1,
               +Handle_2)</CODE></H4>

   Computes the poly-hull \f$P\f$ of the set-theoretic difference of
   the polyhedra referenced by
   <CODE>Handle_1</CODE> and <CODE>Handle_2</CODE>.
   After execution, <CODE>Handle_1</CODE> refers to \f$P\f$.

<H4><CODE>ppl_Polyhedron_widening_assign(+Handle_1, +Handle_2)</CODE></H4>

   Computes the widening \f$P\f$ between the polyhedra referenced by
   <CODE>Handle_1</CODE> and <CODE>Handle_2</CODE>.
   After execution, <CODE>Handle_1</CODE> refers to \f$P\f$.

<H4><CODE>ppl_Polyhedron_limited_widening_assign(+Handle_1, +Handle_2,
               +List_of_Constraints)</CODE></H4>

   Computes the widening \f$P\f$ between the polyhedra referenced by
   <CODE>Handle_1</CODE> and <CODE>Handle_2</CODE>,
   limited by <CODE>List_of_Constraints</CODE>.
   After execution, <CODE>Handle_1</CODE> refers to \f$P\f$.

<H4><CODE>ppl_Polyhedron_get_constraints(+Handle, -List_of_Constraints)
</CODE></H4>

   <CODE>List_of_Constraints</CODE> is unified with a list of
   the constraints in the constraints system
   representing the polyhedron referenced by <CODE>Handle</CODE>.

<H4><CODE>ppl_Polyhedron_get_minimized_constraints(+Handle,
                                                   -List_of_Constraints)
</CODE></H4>

   <CODE>List_of_Constraints</CODE> is unified with a minimized list of
   the constraints in the constraints system
   representing the polyhedron referenced by <CODE>Handle</CODE>.

<H4><CODE>ppl_Polyhedron_get_generators(+Handle, -List_of_Generators)
</CODE></H4>

   <CODE>List_of_Generators</CODE> is unified with a list of
   the generators in the generators system
   representing the polyhedron referenced by <CODE>Handle</CODE>.

<H4><CODE>ppl_Polyhedron_get_minimized_generators(+Handle,
                                                  -List_of_Generators)
</CODE></H4>

   <CODE>List_of_Generators</CODE> is unified with a minimized list of
   the generators in the generators system
   representing the polyhedron referenced by <CODE>Handle</CODE>.

<H4><CODE>ppl_Polyhedron_add_constraint(+Handle, +Constraint)</CODE></H4>

   If \f$CS\f$ is the constraint system representing
   the polyhedron referenced by <CODE>Handle</CODE> before execution,
   then, after execution,
   <CODE>Handle</CODE> refers to the polyhedron
   represented by the constraint system obtained by adding
   <CODE>Constraint</CODE> to \f$CS\f$.
    Thus after executing the query
\code
   ?- ppl_new_Polyhedron_from_dimension(c, 3, X),
      A = '$VAR'(0), B = '$VAR'(1), C = '$VAR'(2),
      ppl_Polyhedron_add_constraint(X, 4*A + B - 2*C >= 5).
\endcode
    the closed polyhedron with handle \p X is defined to be the set of points
    in the vector space \f$\Rset^3\f$ satisfying the constraint
    \f$4x + y - 2z >= 5\f$.

The constraint <CODE>Constraint</CODE> and the
polyhedron referenced by <CODE>Handle</CODE> must be dimension compatible.
This means that the identifiers for the PPL variables in
<CODE>Constraint</CODE> must be strictly less than the space
dimension of the polyhedron. 

<H4><CODE>ppl_Polyhedron_add_generator(+Handle, +Generator)</CODE></H4>

   If \f$GS\f$ is the generator system representing
   the polyhedron referenced by <CODE>Handle</CODE> before execution,
   then, after execution,
   <CODE>Handle</CODE> refers to the polyhedron
   represented by the generator system obtained by adding
   <CODE>Generator</CODE> to \f$GS\f$.
   Thus after the query
\code
   ?- ppl_new_Polyhedron_from_dimension(c, 3, X),
      A = '$VAR'(0), B = '$VAR'(1), C = '$VAR'(2), 
      ppl_Polyhedron_add_generator(X, point(-100*A - 5*B, 8)).
\endcode
    the closed polyhedron with handle \p X is defined to be single point 
    \f$(-12.5, -0.625, 0)^\transpose\f$ in the vector space \f$\Rset^3\f$.

As for <CODE>ppl_Polyhedron_add_constraint</CODE>, the identifiers for the
PPL variables in <CODE>Generator</CODE> must be strictly
less than the space dimension of the polyhedron referenced
by <CODE>Handle</CODE>. 

<H4><CODE>ppl_Polyhedron_add_constraints(+Handle, +List_of_Constraints)
</CODE></H4>

   If \f$CS\f$ is the constraint system representing
   the polyhedron referenced by <CODE>Handle</CODE> before execution,
   then, after execution,
   <CODE>Handle</CODE> refers to the polyhedron
   represented by the constraint system obtained by adding
   the constraints in list <CODE>List_of_Constraints</CODE> to \f$CS\f$.
   E.g.,
\code
   | ?- ppl_new_Polyhedron_from_dimension(c, 2, X),
        A = '$VAR'(0), B = '$VAR'(1),
        ppl_Polyhedron_add_constraints(X, [4*A + B >= 3, A = 1]),
        ppl_Polyhedron_get_constraints(X, CS).
 
   CS = [4*A+1*B>=3,1*A=1] ?
\endcode  
The updated polyhedron referenced by <CODE>Handle</CODE> can be empty
and a query will succeed even when
<CODE>List_of_Constraints</CODE> is unsatisfiable.
                                                                       
<H4><CODE>ppl_Polyhedron_add_constraints_and_minimize(+Handle, 
                                   +List_of_Constraints)</CODE></H4>

   If \f$CS\f$ is the constraint system representing
   the polyhedron referenced by <CODE>Handle</CODE> before execution,
   then, after execution,
   <CODE>Handle</CODE> refers to the polyhedron
   represented by the constraint system obtained by adding
   the constraints in list <CODE>List_of_Constraints</CODE> to \f$CS\f$.
   E.g.,
\code
   ?- ppl_new_Polyhedron_from_dimension(c, 2, X),
      A = '$VAR'(0), B = '$VAR'(1),
      ppl_Polyhedron_add_constraints_and_minimize(X, [4*A + B >= 3, A = 1]),
      ppl_Polyhedron_get_constraints(X, CS).

   CS = [1*B>= -1,1*A=1]
\endcode                                                                          This will fail if, after adding the constraints, the polyhedron is empty.
   E.g., the following will fail,
\code
   ?- A = '$VAR'(0), B = '$VAR'(1),
      ppl_new_Polyhedron_from_dimension(c, 2, X),
      ppl_Polyhedron_add_constraints_and_minimize(X,
        [4*A + B >= 3, A = 0, B =< 0]),
      ppl_Polyhedron_get_constraints(X, CS).
\endcode                                                                              
<H4><CODE>ppl_Polyhedron_add_generators(+Handle, +List_of_Generators)
</CODE></H4>

   If \f$GS\f$ is the generator system representing
   the polyhedron referenced by <CODE>Handle</CODE> before execution,
   then, after execution,
   <CODE>Handle</CODE> refers to the polyhedron
   represented by the generator system obtained by adding
   the generators in list <CODE>List_of_Generators</CODE> to \f$GS\f$.

   If the system of generators representing a polyhedron
   is non-empty, then it must include a point
   (see the paragraph on generator representation in
   the Introduction).
   Thus care must be taken to ensure that, before calling this
   predicate, either the polyhedron referenced by <CODE>Handle</CODE>
   is non-empty or that whenever <CODE>List_of_Generators</CODE> is
   non-empty the first element defines a point.
   E.g.,
\code
   ?- ppl_new_Polyhedron_empty_from_dimension(c, 3, X),
      A='$VAR'(0), B = '$VAR'(1), C = '$VAR'(2),
      ppl_Polyhedron_add_generators(X, 
        [point(1*A + 1*B + 1*C, 1), ray(1*A), ray(2*A)]),
      ppl_Polyhedron_get_generators(X, GS).

   GS = [ray(2*A), point(1*A+1*B+1*C), ray(1*A)]
\endcode
       
<H4><CODE>ppl_Polyhedron_add_generators_and_minimize(+Handle, 
                                   +List_of_Generators)</CODE></H4>

   If \f$GS\f$ is the generator system representing
   the polyhedron referenced by <CODE>Handle</CODE> before execution,
   then, after execution,
   <CODE>Handle</CODE> refers to the polyhedron
   represented by the generator system obtained by adding
   the generators in list <CODE>List_of_Generators</CODE> to \f$GS\f$.

   Unlike the predicate <CODE>ppl_add_generators</CODE>,
   the order of the generators in
   <CODE>List_of_Generators</CODE> is not important.
   E.g.,
\code
   ?- ppl_new_Polyhedron_empty_from_dimension(c, 3, X),
      A='$VAR'(0), B = '$VAR'(1), C = '$VAR'(2),
      ppl_Polyhedron_add_generators_and_minimize(X, 
        [ray(1*A), ray(2*A), point(1*A + 1*B + 1*C, 1)]),
      ppl_Polyhedron_get_generators(X, GS).
 
   GS = [point(1*A+1*B+1*C), ray(1*A)]
\endcode
                                                                       
<H4><CODE>ppl_Polyhedron_add_dimensions_and_constraints(+Handle, 
                                   +List_of_Constraints)</CODE></H4>
 
 
   If, before the call is executed, <CODE>Handle</CODE>
   refers to polyhedron \f$P\f$ and
   <CODE>List_of_Constraints</CODE> refers to a system of constraints
   \f$C\f$ in a space of \f$d\f$ dimensions, then
   $\f$Q\f$ is the polyhedron obtained from \f$P\f$ by
   adding \f$d\f$ new dimensions to \f$P\f$, embedding \f$P\f$
   in the new space and then adding the \f$C\f$ constraints
   to the new space.
   E.g.,
\code
   ?- ppl_new_Polyhedron_from_dimension(nnc, 2, X),
      A = '$VAR'(0), B = '$VAR'(1), C = '$VAR'(2), 
      D = '$VAR'(3), E = '$VAR'(4), 
      ppl_Polyhedron_add_dimensions_and_constraints(X, 
           [A > 1, B >= 0, C >= 0]),
      ppl_Polyhedron_get_constraints(P, CS).

   CS = [1*C > 1, 1*D >= 0, 1*E >= 0]
\endcode

<H4><CODE>ppl_Polyhedron_add_dimensions_and_project(+Handle, +Integer)
</CODE></H4>

   If, before the call is executed, <CODE>Handle</CODE>
   refers to polyhedron \f$P\f$ and
   $\f$Q\f$ is the polyhedron obtained from \f$P\f$ by
   adding <CODE>Integer</CODE> new dimensions and projecting \f$P\f$
   in the new space, then, after execution, <CODE>Handle</CODE>
   refers to \f$Q\f$.
   E.g.,
\code
   ?- ppl_new_Polyhedron_empty_from_dimension(c, 0, X),
      ppl_Polyhedron_add_dimensions_and_project(X, 2),
      ppl_Polyhedron_get_constraints(X, CS),
      ppl_Polyhedron_get_generators(X, GS).
 
   CS = [1*A = 0, 1*B = 0],
   GS = [point(0)]
\endcode

<H4><CODE>ppl_Polyhedron_add_dimensions_and_embed(+Handle, +Integer)
</CODE></H4>

   If, before the call is executed, <CODE>Handle</CODE>
   refers to polyhedron \f$P\f$ and
   $\f$Q\f$ is the polyhedron obtained from \f$P\f$ by
   adding <CODE>Integer</CODE> new dimensions and embedding \f$P\f$
   in the new space, then, after execution, <CODE>Handle</CODE>
   refers to \f$Q\f$.
   E.g.,
\code
   ?- ppl_new_Polyhedron_empty_from_dimension(c, 0, X),
      ppl_Polyhedron_add_dimensions_and_embed(X, 2),
      ppl_Polyhedron_get_constraints(X, CS),
      ppl_Polyhedron_get_generators(X, GS).
 
   CS = [],
   GS = [point(0),line(1*A),line(1*B)]
\endcode

<H4><CODE>ppl_Polyhedron_remove_dimensions(+Handle,
               +List_of_PPL_Vars)</CODE></H4>

   If, before the call is executed, <CODE>Handle</CODE>
   refers to polyhedron \f$P\f$ then,
   after execution, <CODE>Handle</CODE> refers to the polyhedron obtained 
   by removing the dimensions given by the identifiers of the
   PPL variables in list
   <CODE>List_of_PPL_Vars</CODE> from \f$P\f$.
   The identifiers for the remaining PPL variables are renumbered so that
   they are consecutive and the maximum index is less than the number
   of dimensions.
   E.g.,
\code
   ?- ppl_new_Polyhedron_empty_from_dimension(c, 3, X),
      A='$VAR'(0), B = '$VAR'(1), C = '$VAR'(2),
      ppl_Polyhedron_remove_dimensions(X, [B]),
      ppl_Polyhedron_space_dimension(X, K),
      ppl_Polyhedron_get_generators(X, GS). 

   K = 2,
   GS = [point(0),line(1*A),line(1*B),line(0)]         
\endcode

<H4><CODE>ppl_Polyhedron_remove_higher_dimensions(+Handle, +Integer))</CODE></H4>

   If, before the call is executed, <CODE>Handle</CODE>
   refers to polyhedron \f$P\f$ then,
   after execution, <CODE>Handle</CODE> refers to the polyhedron obtained 
   by projecting \f$P\f$ onto the first <CODE>Integer</CODE> dimensions.
   E.g. 
\code
   ?- ppl_new_Polyhedron_empty_from_dimension(c, 5, X),
      ppl_Polyhedron_remove_higher_dimensions(X, 3),
      ppl_Polyhedron_space_dimension(X, K).
 
   K = 3,
\endcode
   The polyhedron \f$P\f$ referenced by <CODE>Handle</CODE>
   must have space dimension \f$k\f$ greater that or equal to
   <CODE>Integer</CODE>.

<H4><CODE>ppl_Polyhedron_affine_image(+Handle, +PPL_Var,
               +LinExpr, +Integer)</CODE></H4>

   Transforms the polyhedron referenced by <CODE>Handle</CODE> 
   assigning the affine expression <CODE>LinExpr</CODE>/<CODE>Integer</CODE>
   to <CODE>PPL_Var</CODE>.

<H4><CODE>ppl_Polyhedron_affine_preimage(+Handle, +PPL_Var,
               +LinExpr, +Integer)</CODE></H4>

This is the inverse transformation to that for <CODE>ppl_affine_image</CODE>.


<H4><CODE>ppl_Polyhedron_relation_with_constraint(+Handle, +Constraint,
               -Relation)</CODE></H4>

Computes the relation the polyhedron \f$P\f$
referenced by <CODE>Handle</CODE>
has with <CODE>Constraint</CODE>.
<CODE>Relation</CODE> is unified to a value as follows:

<CODE>is_disjoint</CODE>, if \f$P\f$
and the set of points satisfying
 <CODE>Constraint</CODE>  are disjoint;

<CODE>strictly_intersects</CODE>, if \f$P\f$
intersects but is not included in the set of points satisfying
 <CODE>Constraint</CODE>;

<CODE>is_included</CODE>, if \f$P\f$
is included in the set of points satisfying
 <CODE>Constraint</CODE>;

<CODE>saturates</CODE>, if \f$P\f$
is included in the set of points saturating
 <CODE>Constraint</CODE>;

<CODE>nothing</CODE>, if nothing is known about the relation.

<H4><CODE>ppl_Polyhedron_relation_with_generator(+Handle, +Generator,
               -Relation)</CODE></H4>

Computes the relation the polyhedron \f$P\f$
referenced by <CODE>Handle</CODE>
has with <CODE>Generator</CODE>.
<CODE>Relation</CODE>, is unified to a value as follows:

<CODE>subsumes</CODE>, if adding <CODE>Generator</CODE>
would not change \f$P\f$;

<CODE>nothing</CODE>, if nothing is known about the relation.


<H4><CODE>ppl_Polyhedron_check_empty(+Handle)</CODE></H4>

   Succeeds if and only if the polyhedron referenced by
   <CODE>Handle</CODE> is empty.

<H4><CODE>ppl_Polyhedron_check_universe(+Handle)</CODE></H4>

   Succeeds if and only if the polyhedron referenced by
   <CODE>Handle</CODE> is the universe.

<H4><CODE>ppl_Polyhedron_is_bounded(+Handle)</CODE></H4>

   Succeeds if and only if the polyhedron referenced by
   <CODE>Handle</CODE> is bounded.

<H4><CODE>ppl_Polyhedron_contains_Polyhedron(+Handle_1, +Handle_2)</CODE></H4>

   Succeeds if and only if the polyhedron \f$P1\f$ referenced by
   <CODE>Handle_1</CODE> is included in or
   equal to the polyhedron \f$P2\f$ referenced by <CODE>Handle_2</CODE>;
   \f$P1\f$ and \f$P2\f$ must have the same topology.

<H4><CODE>ppl_Polyhedron_strictly_contains_Polyhedron(+Handle_1, +Handle_2)</CODE></H4>

   Succeeds if and only if the polyhedron \f$P1\f$ referenced by
   <CODE>Handle_1</CODE> is included in but not
   equal to the polyhedron \f$P2\f$ referenced by <CODE>Handle_2</CODE>;
   \f$P1\f$ and \f$P2\f$ must have the same topology.

<H4><CODE>ppl_Polyhedron_equals_Polyhedron, 2(+Handle_1, +Handle_2)</CODE></H4>

   Succeeds if and only if the polyhedron \f$P1\f$ referenced by
   <CODE>Handle_1</CODE> is
   equal to the polyhedron \f$P2\f$ referenced by <CODE>Handle_2</CODE>;
   \f$P1\f$ and \f$P2\f$ must have the same topology.

<H4><CODE>ppl_Polyhedron_get_bounding_box(+Handle, 
                                      -List_of_Intervals)</CODE></H4>

   Succeeds if and only if the bounding box
   of the polyhedron referenced by
   <CODE>Handle</CODE>
   unifies with the box defined by <CODE>List_of_Intervals</CODE>.
   E.g. 
\code
   ?- A = '$VAR'(0), B = '$VAR'(1),
      ppl_new_Polyhedron_from_ConSys(nnc, [B > 0, 2*A =< 1], P),
      ppl_Polyhedron_get_bounding_box(P, Box).
 
   Box = [i(o(minf), c(1/2)), i(o(0), o(pinf))].
\endcode

*/
