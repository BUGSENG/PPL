/*! \page Prolog_Interface Prolog Interface


\subsection PI_Intro Introduction

To be written.


\subsection PI_SD_Features System-Dependent Features

To be written.


<H4>GNU Prolog</H4>

To be written.


<H4>SWI Prolog</H4>

To be written.


<H4>SICStus Prolog</H4>

In order to use the library you should
load <CODE>ppl_sicstus.pl</CODE>.


\subsection PI_SI_Features System-Independent Features

The PPL predicates provided  for the Prolog interface are specified below.

The specification uses the following grammar rules:
\code
 VarId     -->   non-negative integer  variable identifier

 PPL_Var   -->   '$VAR'(VarId)         PPL variable

 LinExpr   -->    PPL_Var              PPL variable
                | number               integer
                | + LinExpr            unary plus
                | - LinExpr            unary minus
                | LinExpr + LinExpr    addition
                | LinExpr - LinExpr    subtraction
                | number * LinExpr     multiplication
                | LinExpr * number     multiplication

 Constraint -->   LinExpr = LinExpr    equation
                | LinExpr =< LinExpr   nonstrict inequation
                | LinExpr >= LinExpr   nonstrict inequation

 Generator -->    vertex(LinExpr)      vertex
                | vertex(LinExpr,Int)  vertex
                                       (Int is the denominator so that the
                                       vertex is defined by Expr/Int)
                | ray(LinExpr)         ray
                | line(LinExpr)        line
\endcode


There are a few general rules that need to be followed when
using the PPL predicates.

- Argument positions labelled as <CODE>+Address</CODE>
  must be addresses in memory. It is up to the programmer to ensure
  that these addresses refer to a PPL polyhedron.

- A free variable may be bound to an address of a PPL polyhedron
  by using either
  <CODE>ppl_new_polyhedron/2</CODE> or
  <CODE>ppl_copy_polyhedron/2</CODE>.

- Memory occupied by a PPL polyhedron should be released as soon as it is
  no longer required.
  This can be done by executing <CODE>ppl_delete_polyhedron/1</CODE>.
  To understand why this is important,
  consider a Prolog program and a variable that is bound to
  a Herbrand term.
  When the variable dies (goes out of scope) or is uninstantiated
  (on backtracking) the term it is bound to is amenable to garbage collection.
  But this only applies for the standard domain of the language:
  Herbrand terms.
  In Prolog+PPL, addresses of PPL polyhedra are just integers.  
  When variables bound to addresses (i.e. integers) die or are uninstantiated,
  these variables will be garbage-collected, but the polyhedra to which
  the addresses refer will not be released.
  
- For a PPL polyhedron with space dimension \p k,
  the variables used for defining the constraints and the generators
  must have the form, <CODE>'$VAR'(0), ..., '$VAR'(k-1).</CODE>
  Note that the variable identifiers must be strictly less
  than \p k.

- When using the predicates that combine PPL polyhedra
  or insert constraints or generators into a PPL polyhedron,
  the polyhedra referenced and any constraints or generators in the call
  should follow all the rules stated in the dimension-compatibility
  paragraph in the Introduction.

- Note that the vertex specified in the grammar rule for
  <CODE>Generator</CODE> is not necessarily a vertex of a polyhedron. 
  As observed in the Introduction, a set of generators
  representing a polyhedron \f$P\f$ often have to include
  points in \f$P\f$ that are <EM>not</EM> vertices of \f$P\f$.
  Hence, it is convenient to use <EM>vertex</EM> to mean any element of
  the set of generators \f$V\f$, even though it may not be a ``proper''
  vertex of \f$P\f$.


See the specifications of individual predicates for examples and
more information regarding these issues. 

<H4><CODE>ppl_new_polyhedron(-Address, +Integer)</CODE></H4>

   Creates a new universe polyhedron with <CODE>Integer</CODE> dimensions
   with reference <CODE>Address</CODE>.
   Thus the query
\code
   |?- ppl_new_polyhedron(X, 3).
\endcode
   creates the polyhedron defining the 3-dimensional vector space
   \f$\Rset^3\f$ with \p X, the reference address.
   
   The first argument must be a free  variable and
   if it is already instantiated to an address, it will fail. E.g.
   the following will fail:
\code
   | ?- ppl_new_polyhedron(X,3),
        ppl_new_polyhedron(X,3).
\endcode

<H4><CODE>ppl_new_empty_polyhedron(-Address, +Integer)</CODE></H4>

   Creates a new empty polyhedron with <CODE>Integer</CODE> dimensions
   with reference address <CODE>Address</CODE>.
   Thus the query
\code
   |?- ppl_new_empty_polyhedron(X, 3).
\endcode
   creates an empty polyhedron embedded in \f$\Rset^3\f$ with
   \p X the reference address.
   
   The first argument must be a free  variable.
    
<H4><CODE>ppl_delete_polyhedron(+Address)</CODE></H4>

   Deletes the polyhedron referenced by <CODE>Address</CODE>.

   If <CODE>Address</CODE> is not an address of a polyhedron,
   execution is aborted. e.g. the following aborts:
\code
   | ?-ppl_new_polyhedron(X,3),
       ppl_delete_polyhedron(X),
       ppl_delete_polyhedron(X).
\endcode

<H4><CODE>ppl_space_dimension(+Address, -Integer+)</CODE></H4>

   There must be a polyhedron \p P referenced by <CODE>Address</CODE>.
   Returns in <CODE>Integer</CODE> the space dimension of \p P.

   If <CODE>Address</CODE> is not an address of a polyhedron,
   execution succeeds with a large but unspecified dimension.
   E.g. 
\code
   | ?- ppl_new_polyhedron(X,5),
        ppl_delete_polyhedron(X),
        ppl_space_dimension(X,K).
 
     K = 136896952,
     X = -32966754 ?  
\endcode

<H4><CODE>ppl_insert_constraint(+Address, +Constraint)</CODE></H4>

   Adds the constraint <CODE>Constraint</CODE> to the polyhedron 
   referenced by <CODE>Address</CODE>.
    Thus after the query
\code
   |?- A = '$VAR'(0), B = '$VAR'(1), C = '$VAR'(2),
       ppl_new_polyhedron(X, 3),
       ppl_insert_constraint(X, 4*A + B - 2*C >= 5).
\endcode
    the polyhedron referenced by \p X is defined to be the set of points
    in the vector space \f$\Rset^3\f$ satisfying the constraint
    \f$4x + y - 2z >= 5\f$.

The constraint <CODE>Constraint</CODE> and the
polyhedron referenced by <CODE>Address</CODE> must be dimensional compatible.
This means that the identifiers for the variables in
<CODE>Constraint</CODE> must be strictly less than the space
dimension of the polyhedron. 
E.g.
\code
   | ?- ppl_new_polyhedron(X,3),
        ppl_insert_constraint(X,'$VAR'(3) = -12).
   {ERROR: 'PPL::Polyhedron::insert(c):\nthis->space_dimension() == 3, 
   y->space_dimension() == 4'}
\endcode

<H4><CODE>ppl_insert_generator(+Address, +Generator)</CODE></H4>

   Adds the generator <CODE>Generator</CODE> to the polyhedron \p P referenced 
   by <CODE>Address</CODE>.
   Thus after the query
\code
   |?- A = '$VAR'(0), B = '$VAR'(1), C = '$VAR'(2), 
       ppl_new_polyhedron(X, 3),
       ppl_insert_generator(X, vertex(-100*A - 5*B, 8)).
\endcode
    the polyhedron referenced by \p X is defined to be single vertex 
    \f$(-12.5, -0.625, 0)^\transpose\f$ in the vector space \f$\Rset^3\f$.

As for <CODE>ppl_insert_constraint</CODE>, the identifiers for the
variables in <CODE>Generator</CODE> must be strictly
less than the space dimension of the polyhedron referenced
by <CODE>Address</CODE>. 

<H4><CODE>ppl_insert_constraints(+Address, +List_of_Constraints)</CODE></H4>

   Adds the constraints in list <CODE>List_of_Constraints</CODE>
   to the polyhedron referenced by <CODE>Address</CODE>.

<H4><CODE>ppl_insert_generators(+Address, +List_of_Generators)</CODE></H4>

   Adds the generators in list <CODE>List_of_Generators</CODE>
   to the polyhedron referenced by <CODE>Address</CODE> in list order.

   Note that,
   as explained in the paragraph on generator representation in
   the Introduction, a non-empty polyhedron must always have a vertex as
   as one of its generators. Thus care must be taken to ensure that
   before calling this
   predicate that either the polyhedron referenced by <CODE>Address</CODE>
   is non-empty or that whenever <CODE>List_of_Generators</CODE> is
   non-empty the first element defines a vertex.

<H4><CODE>ppl_remove_dimensions(+Address, +List_of_PPL_Vars)</CODE></H4>

   The dimensions corresponding to the identifiers of the variables in list
   <CODE>List_of_PPL_Vars</CODE> are removed from the polyhedron 
   referenced by <CODE>Address</CODE>. E.g.
\code
   | ?- A='$VAR'(0), B = '$VAR'(1), C = '$VAR'(2),
        ppl_new_polyhedron(X, 3),
        ppl_remove_dimensions(X, [B]),
        ppl_space_dimension(X,K),
        ppl_get_generators(X,GS). 
   A = A,
   B = B,
   C = C,
   K = 2,
   X = -32974400,
   GS = [vertex(0),line(1*A),line(1*B),line(0)] ?           
\endcode
Note that as can be seen from this example,
the identifiers for the remaining variables are renumbered so that
they are consecutive and the maximum index is less than the number of
dimensions.

<H4><CODE>ppl_remove_higher_dimensions(+Address, +Integer))</CODE></H4>

   Projects the polyhedron referenced by address <CODE>Address</CODE>
   onto the first <CODE>Integer</CODE> dimensions.
   Thus, if the polyhedron \p P at the <CODE>Address</CODE>
   has space dimension \f$k\f$, <CODE>Integer</CODE>
   must be less than or equal to \f$k\f$. E.g.
\code
   | ?- ppl_new_polyhedron(X,5),
        ppl_remove_higher_dimensions(X,3),
        ppl_space_dimension(X,K).
 
   K = 3,
   X = -33292540 ?

   yes
   | ?- ppl_new_polyhedron(X,5),
        ppl_remove_higher_dimensions(X,6),
        ppl_space_dimension(X,K).
   {ERROR: 'void PPL::Polyhedron::remove_higher_dimensions(nd):
    \nthis->space_dimension() == 5, requested dimension == 6'}
\endcode

<H4><CODE>ppl_add_dimensions_and_embed(+Address, +Integer)</CODE></H4>

   Adds <CODE>Integer</CODE> new dimensions and embeds the old polyhedron
   referenced by <CODE>Address</CODE> in the new space. E.g
\code
   | ?- ppl_new_polyhedron(X,0),
        ppl_add_dimensions_and_embed(X,2),
        ppl_get_constraints(X,CS),
        ppl_get_generators(X,GS).
 
   X = -32775690,
   CS = [],
   GS = [vertex(0),line(1*A),line(1*B)] ?
 
   yes
\endcode
    
<H4><CODE>ppl_add_dimensions_and_project(+Address, +Integer)</CODE></H4>

   Adds <CODE>Integer</CODE> new dimensions and does not
   embed the old polyhedron referenced by <CODE>Address</CODE>
   in the new space. E.g
\code
   | ?- ppl_new_polyhedron(X,0),
        ppl_add_dimensions_and_project(X,2),
        ppl_get_constraints(X,CS),
        ppl_get_generators(X,GS).
 
   X = -32920674,
   CS = [1*A=0,1*B=0],
   GS = [vertex(0)] ?
 
   yes
\endcode

<H4><CODE>ppl_check_empty(+Address)</CODE></H4>

   Succeeds if and only if the polyhedron referenced by
   <CODE>Address</CODE> is empty.

<H4><CODE>ppl_get_constraints(+Address, -List_of_Constraints)</CODE></H4>

   Binds <CODE>List_of_Constraints</CODE>  to the system of constraints
   defining the polyhedron at <CODE>Address</CODE>. E.g.
\code
   | ?- A = '$VAR'(0), B = '$VAR'(1), C = '$VAR'(2), 
        ppl_new_polyhedron(X, 3),
	ppl_insert_constraint(X, 4*A+B-2*C >= 5),
	ppl_get_constraints(X, CS),
	write(CS).
   [4*A+1*B+ -2*C>=5]
   A = A,
   B = B,
   C = C,
   X = -32975760,
   CS = [4*A+1*B+ -2*C>=5] ?
\endcode

<H4><CODE>ppl_get_generators(+Address, -List_of_Generators)</CODE></H4>

   Binds <CODE>List_of_Generators</CODE> to the system of generators
   defining the polyhedron at <CODE>Address</CODE>. E.g.
\code
   | ?- A = '$VAR'(0), B = '$VAR'(1), C = '$VAR'(2), 
        ppl_new_polyhedron(X, 3),
	ppl_insert_constraint(X, 4*A+B-2*C >= 5),
	ppl_get_generators(X, GS),
	write(GS).
   A = A,
   B = B,
   C = C,
   X = -32975734,
   GS = [ray(-1*C),vertex(-5*C,2),line(-2*B+ -1*C),line(-1*A+ -2*C)] ?  
\endcode

<H4><CODE>ppl_intersection_assign(+Address_1, +Address_2)</CODE></H4>

   Computes the intersection of the polyhedra referenced by
   <CODE>Address_1</CODE> and <CODE>Address_2</CODE> and places
   the result at <CODE>Address_1</CODE>.

<H4><CODE>ppl_convex_hull_assign(+Address_1, +Addressn_2)</CODE></H4>

   Computes the convex hull of the polyhedra referenced by
   <CODE>Address_1</CODE> and <CODE>Address_2</CODE> and places
   the result at <CODE>Address_1</CODE>.

<H4><CODE>ppl_widening_assign(+Address_1, +Address_2)</CODE></H4>

   Computes the widening between the polyhedra referenced by
   <CODE>Address_1</CODE> and <CODE>Address_2</CODE> and places
   the result at <CODE>Address_1</CODE>.

*/

