/* Documentation for the Prolog interfaces.
   Copyright (C) 2001, 2002 Roberto Bagnara <bagnara@cs.unipr.it>

This file is part of the Parma Polyhedra Library (PPL).

The PPL is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at your
option) any later version.

The PPL is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
USA.

For the most up-to-date information see the Parma Polyhedra Library
site: http://www.cs.unipr.it/ppl/ . */

/*! \page Prolog_Interface Prolog Interface


\subsection PI_Introduction Introduction

The Parma Polyhedra Library comes equipped with a Prolog interface.
Despite the lack of standardization of Prolog's foreign language interfaces,
the PPL Prolog interface supports several Prolog systems and, to the
extent this is possible, provides a uniform view of the library from
each such systems.

The system-independent features of the library are described in
Section \ref PI_SI_Features.
Section \ref PI_Compilation explains how the various incarnations
of the Prolog interface are compiled and installed.
Section \ref PI_SD_Features illustrates the system-dependent
features of the interface for all the supported systems.

\subsection PI_SI_Features System-Independent Features

The Prolog interface provides access to the PPL polyhedra.
A general introduction to convex polyhedra, their representation in the PPL
and the operations provided by the PPL is given in Sections
\ref preamble, \ref introduction, \ref representation,
and \ref operations of this manual.
Here we just describe those aspects that are specific to the Prolog interface.

For proper operation the Prolog interface must be initialized by calling the
predicate <CODE>ppl_initialize/0</CODE>
and finalized by calling the predicate <CODE>ppl_finalize/0</CODE>.
Both <CODE>ppl_initialize/0</CODE> and <CODE>ppl_finalize/0</CODE>
are guarded against multiple invocations so that calling
<CODE>ppl_initialize/0</CODE> several times makes no harm.
The same holds for <CODE>ppl_finalize/0</CODE>.
However, the first call to <CODE>ppl_initialize/0</CODE>
must occur before any other predicate of the interface is called.
On the other hand, the only interface's predicates callable after
<CODE>ppl_finalize/0</CODE> are <CODE>ppl_finalize/0</CODE> itself
(this further call has no effect) and <CODE>ppl_initialize/0</CODE>,
after which the interface's services are usable again.
Some Prolog systems allow the specification of initialization
and deinitialization functions in their foreign language interfaces.
The corresponding incarnations of the PPL-Prolog interface
have been written so that <CODE>ppl_initialize/0</CODE> and/or
<CODE>ppl_finalize/0</CODE> are called automatically.
Section \ref PI_SD_Features will detail in which cases initialization
and finalization is automatically performed or is left to the Prolog
programmer's responsibility.
However, if you want to write portable applications you may decide
to invoke <CODE>ppl_initialize/0</CODE> and <CODE>ppl_finalize/0</CODE>
explicitly: since they can be called multiple times without problems
this will result in enhanced portability at a cost that is, by all means,
negligible.

The PPL predicates provided by the Prolog interface are specified below.
The specification uses the following grammar rules:
\code
 Topology    --> c | nnc

 VarId       --> non-negative integer	variable identifier

 PPL_Var     --> '$VAR'(VarId)		PPL variable

 LinExpr     --> PPL_Var		PPL variable
            | number			integer
            | + LinExpr			unary plus
            | - LinExpr			unary minus
            | LinExpr + LinExpr		addition
            | LinExpr - LinExpr		subtraction
            | number * LinExpr		multiplication
            | LinExpr * number		multiplication

 Constraint  --> LinExpr = LinExpr	equation
            | LinExpr =< LinExpr	nonstrict inequation
            | LinExpr >= LinExpr	nonstrict inequation
            | LinExpr < LinExpr		strict inequation
            | LinExpr > LinExpr		strict inequation

 Constraint_System			list of constraints
             --> []
            | [Constraint]
            | [Constraint | Constraint_System]

 Generator   --> point(LinExpr)		point
            | point(LinExpr, number)	point
            | closure-point(LinExpr)	closure point
            | closure-point(LinExpr, number)
					closure point
              (Int is the denominator so that the point or
               closure point is defined by Expr/Int.)
            | ray(LinExpr)		ray
            | line(LinExpr)		line

 Generator_System			list of generators
             --> []
	    | [Generator]
	    | [Generator | Generator_System]

 Relation    --> is_disjoint		between a constraint and a polyhedron
	    | strictly_intersects	between a constraint and a polyhedron
	    | is_included		between a constraint and a polyhedron
	    | saturates			between a constraint and a polyhedron
            | subsumes			between a generator and a polyhedron
            | nothing

 Numerator   --> number | + number | - number

 Denominator --> number			number must be non-zero

 Rational    --> number | + number | - number
            | Numerator/Denominator	rational number

 Bound       --> c(Rational)		closed rational limit
            | o(Rational)		open rational limit
            | o(pinf)			unbounded in the positive direction
            | o(minf)			unbounded in the negative direction

 Interval    --> i(Bound, Bound)	rational interval

 Box         --> []
            | [Interval]
            | [Interval | Box]		list of intervals.
\endcode


We first give some general information about using the interface.

-  Access to any PPL polyhedron is provided by means of a Prolog term
   called a <EM>handle</EM>.
   The data structure of a handle,
   is implementation-dependent, system-dependent and
   version-dependent, and, for this reason, deliberately left unspecified.
   What we do guarantee is that a handle is an ordinary Prolog term
   that can be used as such and requiring very little memory.

-  Only terms bound to <EM>valid</EM> handles may be used to access
   PPL polyhedra.
   A handle is made valid by using:
\code
   ppl_new_Polyhedron_from_dimension/3,
   ppl_new_Polyhedron_empty_from_dimension/3,
   ppl_new_Polyhedron_from_Polyhedron/4,
   ppl_new_Polyhedron_from_constraints/3,
   ppl_new_Polyhedron_from_generators/3.
   ppl_new_Polyhedron_from_bounding_box/3.
\endcode
   These predicates will create or copy a PPL polyhedron
   and construct a valid handle for referencing it.
   The first argument
   (in the case of <CODE>ppl_new_Polyhedron_from_Polyhedron/4</CODE>,
   the first and third arguments) denotes the topology
   and can be either <CODE>c</CODE> or <CODE>nnc</CODE>
   indicating a C or NNC polyhedron, respectively.
   The third argument
   (in the case of <CODE>ppl_new_Polyhedron_from_Polyhedron/4</CODE>,
   the fourth argument) is a Prolog term that is
   unified with a new valid handle for accessing this polyhedron.

- As soon as a PPL polyhedron is no longer required,
  the memory occupied by it should be released
  using the PPL predicate <CODE>ppl_delete_Polyhedron/1</CODE>.
  To understand why this is important,
  consider a Prolog program and a variable that is bound to
  a Herbrand term.
  When the variable dies (goes out of scope) or is uninstantiated
  (on backtracking) the term it is bound to is amenable to garbage collection.
  But this only applies for the standard domain of the language:
  Herbrand terms.
  In Prolog+PPL, when a variable bound to a handle for a PPL Polyhedron dies
  or is uninstantiated,
  the handle can be garbage-collected, but the polyhedra to which
  the handle refers will not be released.
  Once a handle has been used as an argument in
  <CODE>ppl_delete_Polyhedron/1</CODE>,
  it becomes invalid.

- For a PPL polyhedron with space dimension \p k,
  the identifiers used for the PPL variables in
  the constraints and the generators
  must lie between 0 and \f$k-1\f$.
  Moreover, when using the predicates that combine PPL polyhedra
  or add constraints or generators to a representation of
  a PPL polyhedron,
  the polyhedra referenced and any constraints or generators in the call
  should follow all the space dimension-compatibility rules stated in
  Section \ref representation.

- As explained above, a polyhedron has a fixed topology C or NNC,
  that is determined at the time of its initialization.
  All subsequent operations on the polyhedron must respect all the
  topological compatibility rules stated in Section \ref representation.

- There are a number of predicates whose name ends with
  <CODE>_and_minimize</CODE>.
  These are provided to help the user obtain better performance.<BR>
  For some of the operations on polyhedra in the PPL,
  the internal representation of a polyhedra has to be <EM>minimized</EM>:
  if it is not already minimized,
  an extra PPL minimization operation is performed first.
  However this operation may be very costly
  and, for this reason, the PPL library is lazy and avoids
  it as much as it can.
  For this reason, a predicate without <CODE>_and_minimize</CODE> ending
  should be used
  unless a minimized representation is needed for the next PPL operation.
  In that case it is more efficient to use
  the <CODE>_and_minimize</CODE> predicate.
  As an example, suppose you have to compute the poly-hull of several
  polyhedra. Then use the
  <CODE>ppl_Polyhedron_poly_hull_assign/2</CODE>
  for each intermediate step and
  <CODE>ppl_Polyhedron_poly_hull_assign_and_minimize/2</CODE>
  for the last step.
  If you just have  to compute the poly-hull of two polyhedra, then use
  <CODE>ppl_Polyhedron_poly_hull_assign_and_minimize/2</CODE>.

<H4><CODE>
  ppl_new_Polyhedron_from_dimension(+Topology, +Integer, -Handle)
</CODE></H4>

   Creates a new universe C or NNC polyhedron \f$\cP\f$,
   depending on the value of <CODE>Topology</CODE>,
   with <CODE>Integer</CODE> dimensions.
   <CODE>Handle</CODE> is unified with the handle for \f$\cP\f$.
   Thus the query
\code
   ?- ppl_new_Polyhedron_from_dimension(c, X, 3).
\endcode
   creates the C polyhedron defining the 3-dimensional vector space
   \f$\Rset^3\f$ with \p X bound to a valid handle for accessing it.

<H4><CODE>
  ppl_new_Polyhedron_empty_from_dimension(+Topology, +Integer, -Handle)
</CODE>
</H4>

   Creates a new empty C or NNC polyhedron \f$\cP\f$,
   depending on the value of <CODE>Topology</CODE>,
   with <CODE>Integer</CODE> dimensions.
   <CODE>Handle</CODE> is unified with the handle for \f$\cP\f$.
   Thus the query
\code
   ?- ppl_new_Polyhedron_empty_from_dimension(nnc, X, 3).
\endcode
   creates an empty NNC polyhedron embedded in \f$\Rset^3\f$ with
   \p X bound to a valid handle for accessing it.

<H4><CODE>
ppl_new_Polyhedron_from_Polyhedron(+Topology_1, +Handle_1,
                                   +Topology_2, -Handle_2)
</CODE></H4>

   If <CODE>Handle_1</CODE> refers to a C or NNC polyhedron \f$\cP_1\f$
   (depending on the value of <CODE>Topology_1</CODE>),
   then this creates a copy \f$\cP_2\f$ of \f$\cP_1\f$
   with topology C or NNC,
   depending on the value of <CODE>Topology_2</CODE>.
   <CODE>Handle_2</CODE> is unified with the handle for \f$\cP_2\f$.
   Thus the query
\code
   ?- ppl_new_Polyhedron_empty_from_dimension(nnc, X, 3),
      ppl_new_Polyhedron_from_Polyhedron(c, X, nnc, Y).
\endcode
   creates an empty C polyhedron embedded in \f$\Rset^3\f$
   referenced by \p X
   and then makes a copy, converting the topology to an NNC polyhedron.
   with \p Y bound to a valid handle for accessing it.

   When using <CODE>ppl_new_Polyhedron_from_Polyhedron/2</CODE>,
   when the source polyhedron is NNC and the copy is C,
   care must be taken that the source polyhedron referenced by
   <CODE>Handle1</CODE> is topologically closed.

<H4><CODE>
   ppl_new_Polyhedron_from_constraints(+Topology,
                   +Constraint_System, -Handle)
</CODE></H4>

   Creates a polyhedron \f$\cP\f$ represented by
   <CODE>Constraint_System</CODE> with topology C or NNC,
   depending on the value of <CODE>Topology</CODE>.
   <CODE>Handle</CODE> is unified with the handle for \f$\cP\f$.

<H4><CODE>
   ppl_new_Polyhedron_from_generators(+Topology,
                   +Generator_System, -Handle)
</CODE></H4>

   Creates a polyhedron \f$\cP\f$ represented by
   <CODE>Generator_System</CODE> with topology C or NNC,
   depending on the value of <CODE>Topology</CODE>.
   <CODE>Handle</CODE> is unified with the handle for \f$\cP\f$.

<H4><CODE>
   ppl_new_Polyhedron_from_bounding_box(+Topology,
                   +Box, -Handle)
</CODE></H4>

   Creates a polyhedron \f$\cP\f$ represented by <CODE>Box</CODE>
   with topology C or NNC,
   depending on the value of <CODE>Topology</CODE>,
   and <CODE>Handle</CODE> is unified with the handle for \f$\cP\f$.
   A bound of the form <CODE>o(Rational)</CODE>
   can be included in an interval in <CODE>Box</CODE>
   only if <CODE>Topology</CODE> is <CODE>nnc</CODE>.

<H4><CODE>ppl_delete_Polyhedron(+Handle)</CODE></H4>

   Deletes the polyhedron referenced by <CODE>Handle</CODE>.
   After execution,
   <CODE>Handle</CODE> is no longer a valid handle for a PPL polyhedron.

<H4><CODE>ppl_Polyhedron_space_dimension(+Handle, -Integer)</CODE></H4>

   Unifies the space dimension of the polyhedron referenced by
   <CODE>Handle</CODE> with <CODE>Integer</CODE>.

<H4><CODE>ppl_Polyhedron_intersection_assign(+Handle_1, +Handle_2)</CODE></H4>
<H4><CODE>ppl_Polyhedron_intersection_assign_and_minimize(+Handle_1,
                     +Handle_2)</CODE></H4>

   Assign to the polyhedron referenced by <CODE>Handle_1</CODE>
   its intersection with the polyhedra referenced by <CODE>Handle_2</CODE>.

<H4><CODE>ppl_Polyhedron_poly_hull_assign(+Handle_1, +Handle_2)</CODE></H4>
<H4><CODE>ppl_Polyhedron_poly_hull_assign_and_minimize(+Handle_1,
               +Handle_2)</CODE></H4>

   Assign to the polyhedron referenced by <CODE>Handle_1</CODE>
   its poly-hull with the polyhedra referenced by <CODE>Handle_2</CODE>.

<H4><CODE>ppl_Polyhedron_poly_difference_assign(+Handle_1, +Handle_2)</CODE></H4>
<H4><CODE>ppl_Polyhedron_poly_difference_assign_and_minimize(+Handle_1,
               +Handle_2)</CODE></H4>

   Assign to the polyhedron referenced by <CODE>Handle_1</CODE>
   its poly-difference with the polyhedron referenced by <CODE>Handle_2</CODE>.

<H4><CODE>ppl_Polyhedron_H79_widening_assign(+Handle_1, +Handle_2)</CODE></H4>

   Assigns to the polyhedron referenced by <CODE>Handle_1</CODE>
   its H79-widening with the polyhedra referenced by <CODE>Handle_2</CODE>,

<H4><CODE>ppl_Polyhedron_limited_H79_widening_assign(+Handle_1, +Handle_2,
               +Constraint_System)</CODE></H4>

   Assigns to the polyhedron referenced by <CODE>Handle_1</CODE>
   its H79-widening with the polyhedron referenced by <CODE>Handle_2</CODE>,
   limited by the constraints in <CODE>Constraint_System</CODE>.

<H4><CODE>ppl_Polyhedron_topological_closure_assign(+Handle)</CODE></H4>

   Assigns to the polyhedron referenced by <CODE>Handle</CODE>
   its topological closure.

<H4><CODE>ppl_Polyhedron_get_constraints(+Handle, -Constraint_System)
</CODE></H4>

   Unifies <CODE>Constraint_System</CODE> with a list of
   the constraints in the constraints system
   representing the polyhedron referenced by <CODE>Handle</CODE>.

<H4><CODE>ppl_Polyhedron_get_minimized_constraints(+Handle,
                                                   -Constraint_System)
</CODE></H4>

   Unifies <CODE>Constraint_System</CODE> with a minimized list of
   the constraints in the constraints system
   representing the polyhedron referenced by <CODE>Handle</CODE>.

<H4><CODE>ppl_Polyhedron_get_generators(+Handle, -Generator_System)
</CODE></H4>

   Unifies <CODE>Generator_System</CODE> with a list of
   the generators in the generators system
   representing the polyhedron referenced by <CODE>Handle</CODE>.

<H4><CODE>ppl_Polyhedron_get_minimized_generators(+Handle,
                                                  -Generator_System)
</CODE></H4>

   Unifies <CODE>Generator_System</CODE> with a minimized list of
   the generators in the generators system
   representing the polyhedron referenced by <CODE>Handle</CODE>.

<H4><CODE>ppl_Polyhedron_add_constraint(+Handle, +Constraint)</CODE></H4>

   Updates the polyhedron referenced by <CODE>Handle</CODE> to
   one obtained by adding
   <CODE>Constraint</CODE> to its constraint system.
   Thus, the query
\code
   ?- ppl_new_Polyhedron_from_dimension(c, 3, X),
      A = '$VAR'(0), B = '$VAR'(1), C = '$VAR'(2),
      ppl_Polyhedron_add_constraint(X, 4*A + B - 2*C >= 5).
\endcode
    will update the polyhedron with handle \p X to consist of
    the set of points
    in the vector space \f$\Rset^3\f$ satisfying the constraint
    \f$4x + y - 2z >= 5\f$.

<H4><CODE>ppl_Polyhedron_add_generator(+Handle, +Generator)</CODE></H4>

   Updates the polyhedron referenced by <CODE>Handle</CODE> to
   one obtained by adding
   <CODE>Generator</CODE> to its generator system.
   Thus, after the query
\code
   ?- ppl_new_Polyhedron_from_dimension(c, 3, X),
      A = '$VAR'(0), B = '$VAR'(1), C = '$VAR'(2),
      ppl_Polyhedron_add_generator(X, point(-100*A - 5*B, 8)).
\endcode
    will update the polyhedron with handle \p X to be the single point
    \f$(-12.5, -0.625, 0)^\transpose\f$ in the vector space \f$\Rset^3\f$.

<H4><CODE>ppl_Polyhedron_add_constraints(+Handle, +Constraint_System)
</CODE></H4>

   Updates the polyhedron referenced by <CODE>Handle</CODE> to
   one obtained by adding to its constraint system the constraints in
   <CODE>Constraint_System</CODE>.
   E.g.,
\code
   | ?- ppl_new_Polyhedron_from_dimension(c, 2, X),
        A = '$VAR'(0), B = '$VAR'(1),
        ppl_Polyhedron_add_constraints(X, [4*A + B >= 3, A = 1]),
        ppl_Polyhedron_get_constraints(X, CS).

   CS = [4*A+1*B>=3,1*A=1] ?
\endcode
The updated polyhedron referenced by <CODE>Handle</CODE> can be empty
and a query will succeed even when
<CODE>Constraint_System</CODE> is unsatisfiable.

<H4><CODE>ppl_Polyhedron_add_constraints_and_minimize(+Handle,
                                   +Constraint_System)</CODE></H4>

   Updates the polyhedron referenced by <CODE>Handle</CODE> to
   one obtained by adding to its constraint system the constraints in
   <CODE>Constraint_System</CODE>.
   E.g.,
\code
   ?- ppl_new_Polyhedron_from_dimension(c, 2, X),
      A = '$VAR'(0), B = '$VAR'(1),
      ppl_Polyhedron_add_constraints_and_minimize(X, [4*A + B >= 3, A = 1]),
      ppl_Polyhedron_get_constraints(X, CS).

   CS = [1*B>= -1,1*A=1]
\endcode                                                                          This will fail if, after adding the constraints, the polyhedron is empty.
   E.g., the following will fail,
\code
   ?- A = '$VAR'(0), B = '$VAR'(1),
      ppl_new_Polyhedron_from_dimension(c, 2, X),
      ppl_Polyhedron_add_constraints_and_minimize(X,
        [4*A + B >= 3, A = 0, B =< 0]),
      ppl_Polyhedron_get_constraints(X, CS).
\endcode
<H4><CODE>ppl_Polyhedron_add_generators(+Handle, +Generator_System)
</CODE></H4>

   Updates the polyhedron referenced by <CODE>Handle</CODE> to
   one obtained by adding to its generator system the generators in
   <CODE>Generator_System</CODE>.

   If the system of generators representing a polyhedron
   is non-empty, then it must include a point
   (see the paragraph on generator representation in
   Section \ref representation).
   Thus care must be taken to ensure that, before calling this
   predicate, either the polyhedron referenced by <CODE>Handle</CODE>
   is non-empty or that whenever <CODE>Generator_System</CODE> is
   non-empty the first element defines a point.
   E.g.,
\code
   ?- ppl_new_Polyhedron_empty_from_dimension(c, 3, X),
      A='$VAR'(0), B = '$VAR'(1), C = '$VAR'(2),
      ppl_Polyhedron_add_generators(X,
        [point(1*A + 1*B + 1*C, 1), ray(1*A), ray(2*A)]),
      ppl_Polyhedron_get_generators(X, GS).

   GS = [ray(2*A), point(1*A+1*B+1*C), ray(1*A)]
\endcode

<H4><CODE>ppl_Polyhedron_add_generators_and_minimize(+Handle,
                                   +Generator_System)</CODE></H4>

   Updates the polyhedron referenced by <CODE>Handle</CODE> to
   one obtained by adding to its generator system the generators in
   <CODE>Generator_System</CODE>.

   Unlike the predicate <CODE>ppl_add_generators</CODE>,
   the order of the generators in
   <CODE>Generator_System</CODE> is not important.
   E.g.,
\code
   ?- ppl_new_Polyhedron_empty_from_dimension(c, 3, X),
      A='$VAR'(0), B = '$VAR'(1), C = '$VAR'(2),
      ppl_Polyhedron_add_generators_and_minimize(X,
        [ray(1*A), ray(2*A), point(1*A + 1*B + 1*C, 1)]),
      ppl_Polyhedron_get_generators(X, GS).

   GS = [point(1*A+1*B+1*C), ray(1*A)]
\endcode

<H4><CODE>ppl_Polyhedron_add_dimensions_and_constraints(+Handle,
                                   +Constraint_System)</CODE></H4>


   After embedding the polyhedron referred to by <CODE>Handle</CODE>
   in a new space that is enlarged by the space dimensions
   of the constraint system in <CODE>Constraint_System</CODE>,
   it then updates the polyhedron referenced by <CODE>Handle</CODE> to
   one obtained by adding to the new space the constraints in
   <CODE>Constraint_System</CODE>.
   E.g.,
\code
   ?- ppl_new_Polyhedron_from_dimension(nnc, 2, X),
      A = '$VAR'(0), B = '$VAR'(1), C = '$VAR'(2),
      D = '$VAR'(3), E = '$VAR'(4),
      ppl_Polyhedron_add_dimensions_and_constraints(X,
           [A > 1, B >= 0, C >= 0]),
      ppl_Polyhedron_get_constraints(P, CS).

   CS = [1*C > 1, 1*D >= 0, 1*E >= 0]
\endcode

<H4><CODE>ppl_Polyhedron_add_dimensions_and_project(+Handle, +Integer)
</CODE></H4>

   Projects the polyhedron referred to by <CODE>Handle</CODE>
   onto a space that is enlarged by <CODE>Integer</CODE> dimensions,
   E.g.,
\code
   ?- ppl_new_Polyhedron_empty_from_dimension(c, 0, X),
      ppl_Polyhedron_add_dimensions_and_project(X, 2),
      ppl_Polyhedron_get_constraints(X, CS),
      ppl_Polyhedron_get_generators(X, GS).

   CS = [1*A = 0, 1*B = 0],
   GS = [point(0)]
\endcode

<H4><CODE>ppl_Polyhedron_add_dimensions_and_embed(+Handle, +Integer)
</CODE></H4>

   Embeds the polyhedron referred to by <CODE>Handle</CODE>
   in a space that is enlarged by <CODE>Integer</CODE> dimensions,
   E.g.,
\code
   ?- ppl_new_Polyhedron_empty_from_dimension(c, 0, X),
      ppl_Polyhedron_add_dimensions_and_embed(X, 2),
      ppl_Polyhedron_get_constraints(X, CS),
      ppl_Polyhedron_get_generators(X, GS).

   CS = [],
   GS = [point(0),line(1*A),line(1*B)]
\endcode

<H4><CODE>ppl_Polyhedron_remove_dimensions(+Handle,
               +List_of_PPL_Vars)</CODE></H4>

   Removes the dimensions given by the identifiers of the
   PPL variables in list <CODE>List_of_PPL_Vars</CODE>
   from the polyhedron referred to by <CODE>Handle</CODE>.
   The identifiers for the remaining PPL variables are renumbered so that
   they are consecutive and the maximum index is less than the number
   of dimensions.
   E.g.,
\code
   ?- ppl_new_Polyhedron_empty_from_dimension(c, 3, X),
      A='$VAR'(0), B = '$VAR'(1), C = '$VAR'(2),
      ppl_Polyhedron_remove_dimensions(X, [B]),
      ppl_Polyhedron_space_dimension(X, K),
      ppl_Polyhedron_get_generators(X, GS).

   K = 2,
   GS = [point(0),line(1*A),line(1*B),line(0)]
\endcode

<H4><CODE>ppl_Polyhedron_remove_higher_dimensions(+Handle, +Integer))</CODE></H4>

   Projects the the polyhedron referred to by <CODE>Handle</CODE>
   onto  the first <CODE>Integer</CODE> dimension.
   E.g.,
\code
   ?- ppl_new_Polyhedron_empty_from_dimension(c, 5, X),
      ppl_Polyhedron_remove_higher_dimensions(X, 3),
      ppl_Polyhedron_space_dimension(X, K).

   K = 3,
\endcode
   The polyhedron \f$\cP\f$ referenced by <CODE>Handle</CODE>
   must have space dimension \f$k\f$ greater that or equal to
   <CODE>Integer</CODE>.

<H4><CODE>ppl_Polyhedron_affine_image(+Handle, +PPL_Var,
               +LinExpr, +Integer)</CODE></H4>

   Transforms the polyhedron referenced by <CODE>Handle</CODE>
   assigning the affine expression <CODE>LinExpr</CODE>/<CODE>Integer</CODE>
   to <CODE>PPL_Var</CODE>.

<H4><CODE>ppl_Polyhedron_affine_preimage(+Handle, +PPL_Var,
               +LinExpr, +Integer)</CODE></H4>

This is the inverse transformation to that for <CODE>ppl_affine_image</CODE>.

<H4><CODE>ppl_Polyhedron_relation_with_constraint(+Handle, +Constraint,
               -Relation)</CODE></H4>

Unifies <CODE>Relation</CODE> with the relation the polyhedron
referenced by <CODE>Handle</CODE>
has with <CODE>Constraint</CODE>.
The possible relations are listed in the grammar rules above;
their meaning is given in Section \ref operations.
The relation  <CODE>nothing</CODE> means that
nothing is known about  the relation the polyhedron
referenced by <CODE>Handle</CODE> has with <CODE>Constraint</CODE>.

<H4><CODE>ppl_Polyhedron_relation_with_generator(+Handle, +Generator,
               -Relation)</CODE></H4>

Unifies <CODE>Relation</CODE> with the relation the polyhedron
referenced by <CODE>Handle</CODE> has with <CODE>Generator</CODE>.
The possible relations are listed in the grammar rules above;
The meaning of the relation <CODE>subsume</CODE>
is given in Section \ref operations.
The relation  <CODE>nothing</CODE> means that
nothing is known about  the relation the polyhedron
referenced by <CODE>Handle</CODE> has with <CODE>Generator</CODE>.

<H4><CODE>ppl_Polyhedron_check_empty(+Handle)</CODE></H4>

   Succeeds if and only if the polyhedron referenced by
   <CODE>Handle</CODE> is empty.

<H4><CODE>ppl_Polyhedron_check_universe(+Handle)</CODE></H4>

   Succeeds if and only if the polyhedron referenced by
   <CODE>Handle</CODE> is the universe.

<H4><CODE>ppl_Polyhedron_is_bounded(+Handle)</CODE></H4>

   Succeeds if and only if the polyhedron referenced by
   <CODE>Handle</CODE> is bounded.

<H4><CODE>ppl_Polyhedron_bounds_from_above(+Handle,
                                   +LinExpr)</CODE></H4>

   Succeeds if and only if <CODE>LinExpr</CODE> is bounded from above in
   the polyhedron referenced by <CODE>Handle</CODE>.


<H4><CODE>ppl_Polyhedron_bounds_from_below(+Handle,
                                   +LinExpr)</CODE></H4>

   Succeeds if and only if <CODE>LinExpr</CODE> is bounded from below in
   the polyhedron referenced by <CODE>Handle</CODE>.


<H4><CODE>ppl_Polyhedron_is_topologically_closed(+Handle)</CODE></H4>

   Succeeds if and only if the polyhedron referenced by
   <CODE>Handle</CODE> is topologically closed.

<H4><CODE>ppl_Polyhedron_contains_Polyhedron(+Handle_1, +Handle_2)</CODE></H4>

   Succeeds if and only if the polyhedron referenced by
   <CODE>Handle_1</CODE> is included in or
   equal to the polyhedron referenced by <CODE>Handle_2</CODE>.

<H4><CODE>ppl_Polyhedron_strictly_contains_Polyhedron(+Handle_1, +Handle_2)</CODE></H4>

   Succeeds if and only if the polyhedron referenced by
   <CODE>Handle_1</CODE> is included in but not
   equal to the polyhedron referenced by <CODE>Handle_2</CODE>.

<H4><CODE>ppl_Polyhedron_equals_Polyhedron, 2(+Handle_1, +Handle_2)</CODE></H4>

   Succeeds if and only if the polyhedron referenced by
   <CODE>Handle_1</CODE> is
   equal to the polyhedron referenced by <CODE>Handle_2</CODE>.

<H4><CODE>ppl_Polyhedron_get_bounding_box(+Handle,
                                      -Box)</CODE></H4>

   Succeeds if and only if the bounding box
   of the polyhedron referenced by
   <CODE>Handle</CODE>
   unifies with the box defined by <CODE>Box</CODE>.
   E.g.,
\code
   ?- A = '$VAR'(0), B = '$VAR'(1),
      ppl_new_Polyhedron_from_constraints(nnc, [B > 0, 4*A =< 2], P),
      ppl_Polyhedron_get_bounding_box(P, Box).

   Box = [i(o(minf), c(1/2)), i(o(0), o(pinf))].
\endcode
Note that the rational numbers in <CODE>Box</CODE> are in canonical form.
E.g., the following will fail:
\code
   ?- A = '$VAR'(0), B = '$VAR'(1),
      ppl_new_Polyhedron_from_constraints(nnc, [B > 0, 4*A =< 2], P),
      ppl_Polyhedron_get_bounding_box(P, Box),
      Box = [i(o(minf), c(2/4)), i(o(0), o(pinf))].
\endcode

\subsection PI_Compilation Compilation and Installation

When the Parma Polyhedra Library is configured, it tests for the existence
of each supported Prolog system.  If a supported Prolog system is
correctly installed in a standard location, things are arranged
so that the corresponding interface is built and installed.

In the sequel, <CODE>prefix</CODE> is the prefix under which
you have installed the library (typically <CODE>/usr</CODE>
or <CODE>/usr/local</CODE>).

As an option, the Prolog interface can track the creation and disposal
of polyhedra.  In fact, differently from native Prolog data, PPL polyhedra
must be explicitly disposed and forgetting to do so is a very common mistake.
To enable this option, configure the library adding
<CODE>-DPROLOG_TRACK_ALLOCATION</CODE> to the options passed to the
C++ compiler.
Your configure command would then look like
\code
  path/to/configure --with-cxxflags="-DPROLOG_TRACK_ALLOCATION" ...
\endcode

\subsection PI_SD_Features System-Dependent Features


<H4>CIAO Prolog</H4>

Support for CIAO Prolog is under development and will be available in
a future release.


<H4>GNU Prolog</H4>

The GNU Prolog interface to the PPL library is available
both as ``PPL enhanced'' GNU Prolog interpreter
and as a library that can be linked to GNU Prolog programs.
Only GNU Prolog version 1.2.12 or later is supported.

Notice that GNU Prolog version 1.2.12 suffers from a serious limitation
as far as foreign code is concerned.
In order to be safe you must configure GNU Prolog with the
<CODE>--disable-ebp</CODE> option (note that this has a negative effect
on performance).
See <A HREF="http://www.cs.unipr.it/pipermail/ppl-devel/2002-June/001777.html">http://www.cs.unipr.it/pipermail/ppl-devel/2002-June/001777.html</A>,
<A HREF="http://www.cs.unipr.it/pipermail/ppl-devel/2002-June/001780.html">http://www.cs.unipr.it/pipermail/ppl-devel/2002-June/001780.html</A>,
<A HREF="http://www.cs.unipr.it/pipermail/ppl-devel/2002-June/001788.html">http://www.cs.unipr.it/pipermail/ppl-devel/2002-June/001788.html</A>
and
<A HREF="http://www.cs.unipr.it/pipermail/ppl-devel/2002-June/001789.html">http://www.cs.unipr.it/pipermail/ppl-devel/2002-June/001789.html</A>
for more information.

<H5>The <CODE>ppl_gprolog</CODE> Executable</H5>

If an appropriate version of GNU Prolog is installed on the machine
on which you compiled the library, the command <CODE>make install</CODE>
will install the executable <CODE>ppl_gprolog</CODE> in the directory
<CODE>prefix/bin</CODE>.
The <CODE>ppl_gprolog</CODE> executable is simply the GNU Prolog
interpreter with the Parma Polyhedra library linked in.
The only thing you should do to use the library is to
call <CODE>ppl_initialize/0</CODE> before any other PPL predicate
and to call <CODE>ppl_finalize/0</CODE> when you are done with the
library.

<H5>Linking the Library To GNU Prolog Programs</H5>

In order to allow linking GNU Prolog programs to the PPL,
the following files are installed in the directory
<CODE>prefix/lib/ppl</CODE>:
<CODE>ppl_gprolog.pl</CODE> contains the required foreign declarations;
<CODE>libppl_gprolog.*</CODE> contain the executable code for the
GNU Prolog interface in various formats (static library, shared library,
libtool library).
If your GNU Prolog program is constituted by, say, <CODE>source1.pl</CODE>
and <CODE>source2.pl</CODE> and you want to create the executable
<CODE>myprog</CODE>, your compilation command may look like
\code
gplc -o myprog prefix/lib/ppl/ppl_gprolog.pl source1.pl source2.pl \
  -L '-Lprefix/lib/ppl -lppl_gprolog -Lprefix/lib -lppl -lgmp -lgmpxx -lstdc++'
\endcode


<H4>SICStus Prolog</H4>

The SICStus Prolog interface to the PPL library is available
both as a statically linked module or as a dynamically linked one.
Only SICStus Prolog version 3.9.0 or later is supported.

<H5>The Statically Linked <CODE>ppl_sicstus</CODE> Executable</H5>

If an appropriate version of SICStus Prolog is installed on the machine
on which you compiled the library, the command <CODE>make install</CODE>
will install the executable <CODE>ppl_sicstus</CODE> in the directory
<CODE>prefix/bin</CODE>.
The <CODE>ppl_sicstus</CODE> executable is simply the SICStus Prolog
system with the Parma Polyhedra library statically linked.
The only thing you should do to use the library is to
load <CODE>prefix/lib/ppl/ppl_sicstus.pl</CODE>.

<H5>Loading the SICStus Interface Dynamically</H5>

In order to dynamically load the library from SICStus Prolog you should
simply load <CODE>prefix/lib/ppl/ppl_sicstus.pl</CODE>.
Notice that, for dynamic linking to work, you should have configured
the library with the <CODE>--enable-shared</CODE> option.


<H4>SWI-Prolog</H4>

The SWI-Prolog interface of the library is available
both as a statically linked module or as a dynamically linked one.
Only SWI-Prolog version 5.0 or later is supported.

<H5>The <CODE>ppl_pl</CODE> Executable</H5>

If an appropriate version of SWI-Prolog is installed on the machine
on which you compiled the library, the command <CODE>make install</CODE>
will install the executable <CODE>ppl_pl</CODE> in the directory
<CODE>prefix/bin</CODE>.
The <CODE>ppl_pl</CODE> executable is simply the SWI-Prolog
shell with the Parma Polyhedra library statically linked:
from within <CODE>ppl_pl</CODE> all the services of the library
are available without further action.

<H5>Loading the SWI-Prolog Interface Dynamically</H5>

In order to dynamically load the library from SWI-Prolog you should
simply load <CODE>prefix/lib/ppl/ppl_swiprolog.pl</CODE>.
This will invoke <CODE>ppl_initialize/0</CODE> automatically
but, at least for SWI-Prolog versions up to 5.0.7, it is the programmer's
responsibility to call <CODE>ppl_finalize/0</CODE>.
Alternatively, you can load the library directly with
\code
:- load_foreign_library('prefix/lib/ppl/libppl_swiprolog').
\endcode
This will call <CODE>ppl_initialize/0</CODE> automatically.
Analogously,
\code
:- unload_foreign_library('prefix/lib/ppl/libppl_swiprolog').
\endcode
will, as part of the unload process, invoke <CODE>ppl_finalize/0</CODE>.

Notice that, for dynamic linking to work, you should have configured
the library with the <CODE>--enable-shared</CODE> option.


<H4>YAP</H4>

The YAP Prolog interface to the PPL library is available
as a dynamically linked module.
Only YAP version 4.3.23 or later is supported.

In order to dynamically load the library from YAP you should
simply load <CODE>prefix/lib/ppl/ppl_yap.pl</CODE>.
This will invoke <CODE>ppl_initialize/0</CODE> automatically;
it is the programmer's responsibility to call <CODE>ppl_finalize/0</CODE>
when the PPL library is no longer needed.
Notice that, for dynamic linking to work, you should have configured
the library with the <CODE>--enable-shared</CODE> option.

*/
