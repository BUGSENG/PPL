%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                   %
%                          Extra test code                          %
%                                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- dynamic(noisy/1).

% check_noisy
% This also executes all the test predicates but also prints some messages
% including the banner, version numbers and expected output from
% the exception tests.

check_noisy :-
   make_noisy,
   check_all,
   make_quiet.

check_extra_noisy :-
   make_extra_noisy,
   check_all,
   make_quiet.

%%%%%%%%%%%% predicates for switching on/off output messages %

make_extra_noisy :-
  (retract(noisy(_)) ->
      make_extra_noisy
  ;
      assertz(noisy(2))
  ).

make_noisy :-
  (retract(noisy(_)) ->
      make_noisy
  ;
      assertz(noisy(1))
  ).

make_quiet :-
  (retract(noisy(_)) ->
      make_quiet
   ; assertz(noisy(0))
  ).

%%%%%%%%%%%% predicates for output messages %%%%%%%%%%%%%%%%%%%%%

error_message(Message):-
   write_all(Message),
   fail.

display_message(Message):-
    noisy(_),
    (noisy(0) -> true ;
     (write_all(Message))
    ).

write_all([]) :- nl.
write_all([Phrase|Phrases]):-
   (Phrase == nl ->
      nl
   ;
      (write(Phrase),
      write(' '))
   ),
   write_all(Phrases).

%%%%%%%%%%%% predicates for variable generation %%%%%%%%%%%%%%%%%%

% make_var_list(+I,+Dimension,?Variable_List)
% constructs a list of variables with indices from I to Dimension - 1.
% It is assumed that I =< Dimension.

make_vars(Dim, Var_List) :-
  make_var_list(0, Dim, Var_List).
make_var_list(Dim, Dim, []) :- !.
make_var_list(I, Dim, ['$VAR'(I)|Var_List]) :-
  (I1 is I + 1,
  make_var_list(I1, Dim, Var_List)).

%%%%%%%%%%%% predicates for success and errors.  %%%%%%%%%%%%%%%%%

write_success(Predicate_name) :-
  display_message([test, for, Predicate_name, 'succeeded.']).

write_error(Predicate_name) :-
  write_all([test, for, Predicate_name, 'failed.']).

%%%%%%%%%%%% predicates for test data %%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- discontiguous(ppl_constraints_test_data/4).
:- discontiguous(ppl_generators_test_data/4).
:- discontiguous(ppl_congruences_test_data/4).
:- discontiguous(ppl_grid_generators_test_data/4).
:- discontiguous(ppl_constraint_test_data/3).
:- discontiguous(ppl_generator_test_data/3).
:- discontiguous(ppl_congruence_test_data/3).
:- discontiguous(ppl_grid_generator_test_data/3).

ppl_initial_test_system(constraint, universe).
ppl_initial_test_system(congruence, universe).
ppl_initial_test_system(generator, empty).
ppl_initial_test_system(grid_generator, empty).

predicate_exists(Predicate) :-
  all_class_dependent_predicates(List_of_Predicates),
  member(Predicate, List_of_Predicates).

/* constraint_systems and generator_systems */

ppl_constraints_test_data(e0, _Topology, 0, [0 = 1]).
ppl_generators_test_data(e0, _Topology, 0, []).

ppl_constraint_test_data(e0, 0 = 1, Rel) :-
  Rel = [saturates, is_included, is_disjoint]
  ; Rel = [saturates, is_disjoint, is_included]
  ; Rel = [is_included, is_disjoint, saturates]
  ; Rel = [is_included, saturates, is_disjoint]
  ; Rel = [is_disjoint, is_included, saturates]
  ; Rel = [is_disjoint, saturates, is_included]
  ; Rel = [is_disjoint, is_included]
  ; Rel = [is_included, is_disjoint].
ppl_generator_test_data(e0, point(0), []).

ppl_constraints_test_data(e1, _Topology, 1, CS) :-
  (make_vars(1, [A]),
   CS = [A >= 1, A =< 0]).
ppl_generators_test_data(e1, _Topology, 1, GS) :-
  (make_vars(1, [A]),
   GS = [line(A)]).

ppl_constraints_test_data(0, _Topology, 0, []).
ppl_generators_test_data(0, _Topology, 0, [point(0)]).

ppl_constraint_test_data(0, 0 = 0, Rel) :-
  Rel = [saturates, is_included] ; Rel = [is_included, saturates]
  ; Rel = [is_included].
ppl_generator_test_data(0, point(0), [subsumes]).

ppl_constraints_test_data(1, _Topology, 1, CS) :-
  (make_vars(1, [A]),
   CS = [A = A]).

ppl_generators_test_data(1, _Topology, 1, GS) :-
  (make_vars(1, [A]),
   GS = [point(0), line(A)]).

ppl_constraint_test_data(1, A = 0, [strictly_intersects]) :-
  make_vars(1, [A]).
ppl_generator_test_data(1, point(0), [subsumes]).

ppl_constraints_test_data(2, _Topology, 1, CS) :-
  (make_vars(1, [A]),
   CS = [A = 1]).

ppl_generators_test_data(2, _Topology, 1, GS) :-
  (make_vars(1, [A]),
   GS = [point(1*A)]).

ppl_constraint_test_data(2, A = 0, [is_disjoint]) :-
  make_vars(1, [A]).
ppl_generator_test_data(2, point(0), []).

ppl_constraints_test_data(3, T, 1, CS) :-
  (T \= t_NNC_,
   make_vars(1, [A]),
   CS = [A >= 0]).

ppl_generators_test_data(3, T, 1, GS) :-
  (T \= t_NNC_,
   make_vars(1, [A]),
   GS = [point(0*A), ray(A)]).

ppl_constraints_test_data(3, t_NNC_, 1, CS) :-
  (make_vars(1, [A]),
   CS = [A > 0]).

ppl_generators_test_data(3, t_NNC_, 1, GS) :-
  (make_vars(1, [A]),
   GS = [closure_point(0*A), point(A), ray(A)]).

ppl_constraint_test_data(3, A =< 3, [strictly_intersects]) :-
  make_vars(1, [A]).
ppl_generator_test_data(3, point(3*A, 2), [subsumes]) :-
  make_vars(1, [A]).

/* congruence_systems and grid_generator_systems */

ppl_congruences_test_data(e0, _Topology, 0, [0 = 1]).
ppl_grid_generators_test_data(e0, _Topology, 0, []).

ppl_congruence_test_data(e0, 0 = 1, Rel) :-
  Rel = [is_included, is_disjoint] ; Rel = [is_disjoint, is_included].
ppl_grid_generator_test_data(e0, grid_point(0), []).

ppl_congruences_test_data(e1, _Topology, 1, CS) :-
  (make_vars(1, [A]),
   CS = [(A =:= 1) / 2, (A =:= 0) / 2]).
ppl_grid_generators_test_data(e1, _Topology, 1, GS) :-
  (make_vars(1, [A]),
   GS = [grid_line(A)]).

ppl_congruences_test_data(0, _Topology, 0, []).
ppl_grid_generators_test_data(0, _Topology, 0, [grid_point(0)]).

ppl_congruence_test_data(0, 0 = 0, [is_included]).
ppl_grid_generator_test_data(0, grid_point(0), [subsumes]).

ppl_congruences_test_data(1, _Topology, 1, CS) :-
  (make_vars(1, [A]),
   CS = [A = A]).

ppl_grid_generators_test_data(1, _Topology, 1, GS) :-
  (make_vars(1, [A]),
   GS = [grid_point(0), grid_line(A)]).

ppl_congruence_test_data(1, A = 0, [strictly_intersects]) :-
  make_vars(1, [A]).
ppl_grid_generator_test_data(1, grid_point(0), [subsumes]).

ppl_congruences_test_data(2, _Topology, 1, CS) :-
  (make_vars(1, [A]),
   CS = [A = 1]).

ppl_grid_generators_test_data(2, _Topology, 1, GS) :-
  (make_vars(1, [A]),
   GS = [grid_point(1*A)]).

ppl_congruence_test_data(2, A = 0, [is_disjoint]) :-
  make_vars(1, [A]).
ppl_grid_generator_test_data(2, grid_point(0), []).

ppl_congruences_test_data(3, _Topology, 1, CS) :-
  (make_vars(1, [A]),
   CS = [A =:= 0]).

ppl_grid_generators_test_data(3, _Topology, 1, GS) :-
  (make_vars(1, [A]),
   GS = [grid_point(0*A), parameter(1*A)]).

ppl_congruence_test_data(3, (2*A =:= 1) / 3, [strictly_intersects]) :-
  make_vars(1, [A]).
ppl_grid_generator_test_data(3, grid_point(3*A), [subsumes]) :-
  make_vars(1, [A]).

/* boxes  */

ppl_box_test_data(e0, _Topology, 0, [empty]).
ppl_box_test_data(e1, _Topology, 1, [empty]).
ppl_box_test_data(0, _Topology, 0, []).
ppl_box_test_data(1, _Topology, 1, [i(o(minf), o(pinf))]).
ppl_box_test_data(2, _Topology, 1, [i(c(1), c(1))]).
ppl_box_test_data(3, _Topology, 1, [i(c(0), o(pinf))]).
ppl_box_test_data(4, _Topology, 2, [i(c(1/2), o(pinf)), i(o(minf), c(-1/2))]).
ppl_box_test_data(5, _Topology, 2, [i(c(-4), c(1)), i(c(-1), c(1))]).
ppl_box_test_data(6, T, 2, [i(c(0/2), o(pinf)), i(o(minf), c(1))]) :-
  T \= t_NNC_.
ppl_box_test_data(6, t_NNC_, 2, [i(o(0/2), o(pinf)), i(o(minf), o(1))]).
