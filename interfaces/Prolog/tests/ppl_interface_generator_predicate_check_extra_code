%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                   %
%                          Extra test code                          %
%                                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- dynamic(noisy/1).

% check_noisy
% This also executes all the test predicates but also prints some messages
% including the banner, version numbers and expected output from
% the exception tests.

check_noisy :-
   make_noisy,
   check_all,
   make_quiet.

check_extra_noisy :-
   make_extra_noisy,
   check_all,
   make_quiet.

%%%%%%%%%%%% predicates for switching on/off output messages %

make_extra_noisy :-
  (retract(noisy(_)) ->
      make_extra_noisy
  ;
      assertz(noisy(2))
  ).

make_noisy :-
  (retract(noisy(_)) ->
      make_noisy
  ;
      assertz(noisy(1))
  ).

make_quiet :-
  (retract(noisy(_)) ->
      make_quiet
   ; assertz(noisy(0))
  ).

%%%%%%%%%%%% predicates for output messages %%%%%%%%%%%%%%%%%%%%%

error_message(Message):-
   write_all(Message),
   fail.

display_message(Message):-
    noisy(_),
    (noisy(0) -> true ;
     (write_all(Message))
    ).

write_all([]) :- nl.
write_all([Phrase|Phrases]):-
   (Phrase == nl ->
      nl
   ;
      (write(Phrase),
      write(' '))
   ),
   write_all(Phrases).

%%%%%%%%%%%% predicates for variable generation %%%%%%%%%%%%%%%%%%

% make_var_list(+I,+Dimension,?Variable_List)
% constructs a list of variables with indices from I to Dimension - 1.
% It is assumed that I =< Dimension.

make_vars(Dim, Var_List) :-
  make_var_list(0, Dim, Var_List).
make_var_list(Dim, Dim, []) :- !.
make_var_list(I, Dim, ['$VAR'(I)|Var_List]) :-
  (I1 is I + 1,
  make_var_list(I1, Dim, Var_List)).

%%%%%%%%%%%% predicates for success and errors.  %%%%%%%%%%%%%%%%%

write_success(Predicate_name) :-
  display_message([test, for, Predicate_name, 'succeeded.']).

write_error(Predicate_name) :-
  write_all([test, for, Predicate_name, 'failed.']).

%%%%%%%%%%%% predicates for test data %%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- discontiguous(ppl_build_test_data/5).
:- discontiguous(ppl_relation_test_data/4).
:- discontiguous(ppl_property_test_data/4).
:- discontiguous(ppl_bounds_test_data/5).

ppl_initial_test_system(constraint, universe).
ppl_initial_test_system(congruence, universe).
ppl_initial_test_system(generator, empty).
ppl_initial_test_system(grid_generator, empty).

predicate_exists(Predicate) :-
  all_class_dependent_predicates(List_of_Predicates),
  member(Predicate, List_of_Predicates).

/* Test data for test e0 (an empty object in 0 dimensions) */

ppl_build_test_data(e0, _Topology, constraints, 0, [0 = 1]).
ppl_build_test_data(e0, _Topology, generators, 0, []).
ppl_build_test_data(e0, _Topology, congruences, 0, [0 = 1]).
ppl_build_test_data(e0, _Topology, grid_generators, 0, []).

ppl_relation_test_data(e0, constraint, 0 = 1, Rel) :-
  Rel = [saturates, is_included, is_disjoint]
  ; Rel = [saturates, is_disjoint, is_included]
  ; Rel = [is_included, is_disjoint, saturates]
  ; Rel = [is_included, saturates, is_disjoint]
  ; Rel = [is_disjoint, is_included, saturates]
  ; Rel = [is_disjoint, saturates, is_included]
  ; Rel = [is_disjoint, is_included]
  ; Rel = [is_included, is_disjoint].
ppl_relation_test_data(e0, generator, point(0), []).
ppl_relation_test_data(e0, congruence, 0 = 1, Rel) :-
  Rel = [is_included, is_disjoint] ; Rel = [is_disjoint, is_included].
ppl_relation_test_data(e0, grid_generator, grid_point(0), []).

ppl_property_test_data(e0, _, _, is_empty).
ppl_property_test_data(e0, _, _, is_bounded).
ppl_property_test_data(e0, _, _, is_topologically_closed).
ppl_property_test_data(e0, _, _, is_discrete).

ppl_bounds_test_data(e0, _, 0, _, true).

/* Test data for test e1 (an empty object in 1 dimension) */

ppl_build_test_data(e1, _Topology, constraints, 1, CS) :-
  (make_vars(1, [A]),
   CS = [A >= 1, A =< 0]).
ppl_build_test_data(e1, _Topology, generators, 1, GS) :-
  (make_vars(1, [A]),
   GS = [line(A)]).
ppl_build_test_data(e1, _Topology, congruences, 1, CS) :-
  (make_vars(1, [A]),
   CS = [(A =:= 1) / 2, (A =:= 0) / 2]).
ppl_build_test_data(e1, _Topology, grid_generators, 1, GS) :-
  (make_vars(1, [A]),
   GS = [grid_line(A)]).

ppl_property_test_data(e1, _, _, is_empty).
ppl_property_test_data(e1, _, _, is_bounded).
ppl_property_test_data(e1, _, _, is_topologically_closed).
ppl_property_test_data_(e1, _, _, is_discrete).

ppl_bounds_test_data(e1, _, A, _, true) :-
  make_vars(1, [A]).

/* Test data for test 0 (a universe object in 0 dimensions) */

ppl_build_test_data(0, _Topology, constraints, 0, []).
ppl_build_test_data(0, _Topology, generators, 0, [point(0)]).
ppl_build_test_data(0, _Topology, congruences, 0, []).
ppl_build_test_data(0, _Topology, grid_generators, 0, [grid_point(0)]).

ppl_relation_test_data(0, constraint, 0 = 0, Rel) :-
  Rel = [saturates, is_included] ; Rel = [is_included, saturates]
  ; Rel = [is_included].
ppl_relation_test_data(0, generator, point(0), [subsumes]).
ppl_relation_test_data(0, congruence, 0 = 0, [is_included]).
ppl_relation_test_data(0, grid_generator, grid_point(0), [subsumes]).

ppl_property_test_data(0, _, _, is_bounded).
ppl_property_test_data(0, _, _, is_topologically_closed).
ppl_property_test_data(0, _, _, is_discrete).
ppl_property_test_data(0, _, _, contains_integer_point).

ppl_bounds_test_data(0, _, 0, _, true).

/* Test data for test 1 (a universe object in 1 dimension) */

ppl_build_test_data(1, _Topology, constraints, 1, CS) :-
  (make_vars(1, [A]),
   CS = [A = A]).
ppl_build_test_data(1, _Topology, generators, 1, GS) :-
  (make_vars(1, [A]),
   GS = [point(0), line(A)]).
ppl_build_test_data(1, _Topology, congruences, 1, CS) :-
  (make_vars(1, [A]),
   CS = [A = A]).
ppl_build_test_data(1, _Topology, grid_generators, 1, GS) :-
  (make_vars(1, [A]),
   GS = [grid_point(0), grid_line(A)]).

ppl_relation_test_data(1, constraint, A = 0, [strictly_intersects]) :-
  make_vars(1, [A]).
ppl_relation_test_data(1, generator, point(0), [subsumes]).
ppl_relation_test_data(1, congruence, A = 0, [strictly_intersects]) :-
  make_vars(1, [A]).
ppl_relation_test_data(1, grid_generator, grid_point(0), [subsumes]).

ppl_property_test_data(1, _, _, is_universe).
ppl_property_test_data(1, _, _, is_topologically_closed).
ppl_property_test_data(1, _, _, contains_integer_point).

ppl_bounds_test_data(1, _, A, _, false) :-
  make_vars(1, [A]).

/* Test data for test 2 (an object in 1 dimension with a single point) */

ppl_build_test_data(2, _Topology, constraints, 1, CS) :-
  (make_vars(1, [A]),
   CS = [A = 1]).

ppl_build_test_data(2, _Topology, generators, 1, GS) :-
  (make_vars(1, [A]),
   GS = [point(1*A)]).
ppl_build_test_data(2, _Topology, congruences, 1, CS) :-
  (make_vars(1, [A]),
   CS = [A = 1]).
ppl_build_test_data(2, _Topology, grid_generators, 1, GS) :-
  (make_vars(1, [A]),
   GS = [grid_point(1*A)]).

ppl_relation_test_data(2, constraint, A = 0, [is_disjoint]) :-
  make_vars(1, [A]).
ppl_relation_test_data(2, generator, point(0), []).
ppl_relation_test_data(2, congruence, A = 0, [is_disjoint]) :-
  make_vars(1, [A]).
ppl_relation_test_data(2, grid_generator, grid_point(0), []).

ppl_property_test_data(2, _, _, is_bounded).
ppl_property_test_data(2, _, _, is_topologically_closed).
ppl_property_test_data(2, _, _, contains_integer_point).
ppl_property_test_data(2, _, _, is_discrete).

ppl_bounds_test_data(2, _, A, _, true) :-
  make_vars(1, [A]).

/* Test data for test 3 (an unbounded non-universe object in 1 dimension) */

ppl_build_test_data(3, T, constraints, 1, CS) :-
  (\+ T == t_NNC_,
   make_vars(1, [A]),
   CS = [A >= 0]).
ppl_build_test_data(3, T, generators, 1, GS) :-
  (\+ T == t_NNC_,
   make_vars(1, [A]),
   GS = [point(0*A), ray(A)]).
ppl_build_test_data(3, t_NNC_, constraints, 1, CS) :-
  (make_vars(1, [A]),
   CS = [A > 0]).
ppl_build_test_data(3, t_NNC_, generators, 1, GS) :-
  (make_vars(1, [A]),
   GS = [closure_point(0*A), point(A), ray(A)]).
ppl_build_test_data(3, _Topology, congruences, 1, CS) :-
  (make_vars(1, [A]),
   CS = [A =:= 0]).
ppl_build_test_data(3, _Topology, grid_generators, 1, GS) :-
  (make_vars(1, [A]),
   GS = [grid_point(0*A), parameter(1*A)]).

ppl_relation_test_data(3, constraint, A =< 3, [strictly_intersects]) :-
  make_vars(1, [A]).
ppl_relation_test_data(3, generator, point(3*A, 2), [subsumes]) :-
  make_vars(1, [A]).
ppl_relation_test_data(3, congruence, (2*A =:= 1) / 3,
                                              [strictly_intersects]) :-
  make_vars(1, [A]).
ppl_relation_test_data(3, grid_generator, grid_point(3*A), [subsumes]) :-
  make_vars(1, [A]).

ppl_property_test_data(3, T, _, is_topologically_closed) :-
  \+ T == t_NNC_.
ppl_property_test_data(3, _, _, contains_integer_point).
ppl_property_test_data(3, _, congruence, is_discrete).

ppl_bounds_test_data(3, _, A, above, false) :-
  make_vars(1, [A]).
ppl_bounds_test_data(3, constraint, A, below, true) :-
  make_vars(1, [A]).
ppl_bounds_test_data(3, congruence, A, below, false) :-
  make_vars(1, [A]).

/* boxes  */

ppl_build_test_data(e0, _Topology, box, 0, [empty]).
ppl_build_test_data(e1, _Topology, box, 1, [empty]).
ppl_build_test_data(0, _Topology, box, 0, []).
ppl_build_test_data(1, _Topology, box, 1, [i(o(minf), o(pinf))]).
ppl_build_test_data(2, _Topology, box, 1, [i(c(1), c(1))]).
ppl_build_test_data(3, _Topology, box, 1, [i(c(0), o(pinf))]).
ppl_build_test_data(4, _Topology, box, 2,
                               [i(c(1/2), o(pinf)), i(o(minf), c(-1/2))]).
ppl_build_test_data(5, _Topology, box, 2, [i(c(-4), c(1)), i(c(-1), c(1))]).
ppl_build_test_data(6, T, box, 2, [i(c(0/2), o(pinf)), i(o(minf), c(1))]) :-
  T \= t_NNC_.
ppl_build_test_data(6, t_NNC_, box, 2, [i(o(0/2), o(pinf)), i(o(minf), o(1))]).
