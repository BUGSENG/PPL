/* Documentation for the Java interface.
   Copyright (C) 2001-2008 Roberto Bagnara <bagnara@cs.unipr.it>

This file is part of the Parma Polyhedra Library (PPL).

The PPL is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 3 of the License, or (at your
option) any later version.

The PPL is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02111-1307, USA.

For the most up-to-date information see the Parma Polyhedra Library
site: http://www.cs.unipr.it/ppl/ . */

/*! \mainpage Java Language Interface

The Parma Polyhedra Library comes equipped with an interface for the
Java language.

The main features of the library are described in
Section \ref Java_Features "Java Interface Features".
Section \ref Java_Generated_Methods "Java Generated Methods"
lists all the methods available to the classes for
a cross-section of the available domains for the Java interface.
Section \ref Java_Compilation "Compilation and Installation"
explains how the Java interface is compiled and installed.

In the sequel, <CODE>prefix</CODE> is the prefix under which
you have installed the library (typically <CODE>/usr</CODE>
or <CODE>/usr/local</CODE>).


\anchor Java_Features
<H1>Java Interface Features</H1>

The Java interface provides access to the numerical abstractions
(convex polyhedra, BD shapes, octagonal shapes, etc.) implemented
by the PPL library.
A general introduction to the numerical abstractions,
their representation in the PPL and the operations provided
by the PPL is given in the main \extref{preamble, PPL user manual}.
Here we just describe those aspects that are specific to the Java interface.

\anchor Java_Interface_Overview
<H2>Overview</H2>

First, here is a list of notes with general information and advice
on the use of the Java interface.

- The numerical abstract domains available to the Java user as Java classes
  consist of the <EM>simple</EM> domains, <EM>powersets</EM> of
  a simple domain and <EM>products</EM> of simple domains.
  - The simple domains are:
     - convex polyhedra, which consist of C_Polyhedron and
       NNC_Polyhedron;<BR>
     - weakly relational, which consist of BD_Shape_N and
       Octagonal_Shape_N
       where N is one of the numeric types
       short, signed_char, int, long, long_long,
       mpz_class, mpq_class;<BR>
     - boxes which consist of
       Int8_Box, Int16_Box,
       Int32_Box, Int64_Box,
       Uint8_Box, Uint16_Box,
       Uint32_Box, Uint64_Box,
       Double_Box, Long_Double_Box,
       Z_Box, Rational_Box, Float_Box; and<BR>
     - the Grid domain.
  - The powerset domains are Pointset_Powerset_S where S is
    a simple domain.
  - The product domains consist of
    Direct_Product_S_T,
    Smash_Product_S_T and
    Constraints_Product_S_T where S
    and T are simple domains.
- In the following, any of the above numerical
  abstract domains  is called a PPL <EM>domain</EM>
  and any element of a PPL domain is called a <EM>PPL object</EM>.
- The Java interface files are all installed in the directory
  <CODE>prefix/lib/ppl</CODE>.  Since this includes shared and
  dynamically loaded libraries, you must make your dynamic
  linker/loader aware of this fact.  If you use a GNU/Linux system,
  try the commands <CODE>man ld.so</CODE> and <CODE>man ldconfig</CODE>
  for more information.
- A Java program can create a new object for a PPL domain by
  using the constructors for the class corresponding to the domain.
- For a PPL object with space dimension \p k,
  the identifiers used for the PPL variables
  must lie between 0 and \f$k-1\f$ and correspond to the indices of the
  associated Cartesian axes.
  For example, when using methods that combine PPL polyhedra
  or add constraints or generators to a representation of
  a PPL polyhedron,
  the polyhedra referenced and any constraints or generators in the call
  should follow all the (space) dimension-compatibility rules stated in
  Section \extref{representation, Representations of Convex Polyhedra}
  of the main PPL user manual.
- As explained above, a polyhedron has a fixed topology C or NNC,
  that is determined at the time of its initialization.
  All subsequent operations on the polyhedron must respect all the
  topological compatibility rules stated in Section
  \extref{representation, Representations of Convex Polyhedra}
  of the main PPL user manual.
- Any application using the PPL should make sure that only the
  intended version(s) of the library are ever used.
  Functions
\code
  version_major/1,
  version_minor/1,
  version_revision/1,
  version_beta/1,
  version/1,
  banner.
\endcode
  allow run-time checking of information about the version being used.

\anchor Java_method_descriptions
<H2> Method Descriptions </H2>

Below is a short description of many of the interface methods.
For full definitions of terminology used here, see the main PPL user manual.

\anchor di_methods
<H3> Domain Independent Methods </H3>

First we describe some domain independent methods
included with all instantiations of the OCaml interfaces.

<H2><CODE> version_major() </CODE></H2>
  Returns the major number of the PPL version.

<H2><CODE> version_minor() </CODE></H2>
  Returns the minor number of the PPL version.

<H2><CODE> version_revision() </CODE></H2>
  Returns the revision number of the PPL version.

<H2><CODE> version_beta() </CODE></H2>
  Returns the beta number of the PPL version.

<H2><CODE> version() </CODE></H2>
  Returns the PPL version.

<H2><CODE> banner() </CODE></H2>
  Returns information about the PPL version, the licensing, the lack of any
  warranty whatsoever, the C++ compiler used to build the library,
  where to report bugs and where to look for further information.

<H2><CODE> ppl_set_rounding_for_PPL() </CODE></H2>
  Sets the FPU rounding mode so that the PPL abstractions based on
  floating point numbers work correctly.

<H2><CODE> ppl_restore_pre_PPL_rounding() </CODE></H2>
  Restores the FPU rounding mode to what it was before the initialization
  of the PPL.

<H2><CODE> max_space_dimension() </CODE></H2>
  Returns the maximum space dimension this library can handle.

<H2><CODE> set_timeout_exception_atom(name) </CODE></H2>
   Sets the term to be thrown by timeout exceptions
   to <CODE>name</CODE>.
   The default value is <CODE>time_out</CODE>.

<H2><CODE> timeout_exception_atom() </CODE></H2>
   Returns the name to be thrown by timeout exceptions

<H2><CODE> set_timeout(c_unsigned) </CODE></H2>
   Computations taking exponential time will be interrupted
   some time after <CODE>c_unsigned</CODE> ms after that call.
   If the computation is interrupted that way, the current timeout
   exception atom will be thrown.
   <CODE>c_unsigned</CODE> must be strictly greater than zero.

<H2><CODE> reset_timeout() </CODE></H2>
   Resets the timeout time so that the computation is not interrupted.

<BR>

\anchor Java_mip_methods
<H3> MIP Methods </H3>
Here we describe some methods available for PPL objects
defining mixed integer (linear) programming problems.

<H2><CODE>
  MIP_Problem(dimension)
</CODE></H2>
   Initializes a reference to an MIP Problem \f$\mathrm{MIP}\f$ with the
   feasible region the vector space of dimension <CODE>dimension</CODE>,
   objective function \f$0\f$ and optimization mode <CODE>max</CODE>.

<H2><CODE>
  MIP_Problem(constraint_system, lin_expr, optimization_mode)
</CODE></H2>
   Initializes a reference to an MIP Problem \f$\mathrm{MIP}\f$ with the
   feasible region represented by <CODE>constraint_system</CODE>,
   objective function <CODE>lin_expr</CODE> and optimization mode
   <CODE>optimization_mode</CODE>.

<H2><CODE>
  space_dimension()
</CODE></H2>
   Returns the dimension of the vector space in which the
   MIP Problem referred to by \p this is embedded.

<H2><CODE>
  integer_space_dimensions()
</CODE></H2>
   Returns a <CODE>Variable_Set</CODE> object
   representing the integer space dimensions of the MIP Problem
   referred to by \p this.

<H2><CODE>
  constraints()
</CODE></H2>
   Returns a <CODE>Constraint_System</CODE> object
   representing the feasible region for the MIP Problem
   referred to by \p this.

<H2><CODE>
  objective_function()
</CODE></H2>
   Returns the objective function for the MIP Problem referred to by \p this.

<H2><CODE>
  optimization_mode()
</CODE></H2>
   Returns the optimization mode
   for the MIP Problem referred to by \p this.

<H2><CODE>
  clear()
</CODE></H2>
  Resets the MIP problem referred to by \p this
  to be the trivial problem with
  the feasible region the \f$0\f$-dimensional universe,
  objective function \f$0\f$ and optimization mode <CODE>Maximization</CODE>.

<H2><CODE> add_space_dimensions_and_embed
            (dimension)
 </CODE></H2>
   Embeds the MIP problem referred to by \p this
   in a space that is enlarged by <CODE>dimension</CODE> dimensions,

<H2><CODE>
  add_to_integer_space_dimensions(var_set)
</CODE></H2>
   Updates the MIP Problem referred to by \p this
   so that the veariables represented by the <CODE>Variable_Set</CODE>
   object <CODE>var_set</CODE> are added to
   the set of integer space dimensions.

<H2><CODE>
  add_constraint(constraint)
</CODE></H2>
   Updates the MIP Problem referred to by \p this
   so that the feasible region is represented by the original constraint
   system together with the constraint <CODE>constraint</CODE>.

<H2><CODE>
  add_constraints(constraint_system)
</CODE></H2>
   Updates the MIP Problem referred to by \p this
   so that the feasible region is represented by the original constraint
   system together with all the constraints in <CODE>constraint_system</CODE>.

<H2><CODE>
  set_objective_function(lin_expr)
</CODE></H2>
   Updates the MIP Problem referred to by \p this
   so that the objective function is changed to <CODE>lin_expr</CODE>.

<H2><CODE>
  set_optimization_mode(optimization_mode)
</CODE></H2>
   Updates the MIP Problem referred to by \p this
   so that the optimization mode is changed to <CODE>optimization_mode</CODE>.

<H2><CODE>
  is_satisfiable()
</CODE></H2>
  Returns true if the MIP Problem referred to by \p this
  is satisfiable and false otherwise.

<H2><CODE>
  solve()
</CODE></H2>
  Solves the MIP problem  referred to by \p this
  and returns <CODE>UNFEASIBLE_MIP_PROBLEM</CODE>,
  if the MIP problem is not satisfiable;
  <CODE>UNBOUNDED_MIP_PROBLEM</CODE>, if the MIP problem is satisfiable but
  there is no finite bound to the value of the objective function;
  <CODE>OPTIMIZED_MIP_PROBLEM</CODE>,
  if the MIP problem admits an optimal solution.

<H2><CODE>
  feasible_point()
</CODE></H2>
  Returns a feasible point for the MIP problem
  referred to by \p this.

<H2><CODE>
  optimizing_point()
</CODE></H2>
  Returns an optimizing point for the MIP problem
  referred to by \p this.

<H2><CODE>
  optimal_value(coeff_1, coeff_2)
</CODE></H2>
  <CODE>coeff_1</CODE> is the numerator and
  the <CODE>coeff_1</CODE> the denominator for the optimal value
  for the MIP problem referred to by \p this.

<H2><CODE>
  evaluate_objective_function(generator, coeff_1, coeff_2)
</CODE></H2>
  Evaluates the objective function of the MIP problem
  at point <CODE>generator</CODE>.
  <CODE>coeff_1</CODE> is the numerator and
  the <CODE>coeff_1</CODE> the denominator for the objective function value
  for the MIP problem referred to by \p this.

<H2><CODE>
  OK()
</CODE></H2>
   Returns true if the MIP Problem referred to by \p this
   is well formed, i.e., if it
   satisfies all its implementation invariants and false,
   otherwise.  Useful for debugging purposes.

<BR>

\anchor main_Java_C_polyhedron_methods
<H3> C_Polyhedron Constructors and Methods </H3>
Here we describe the main methods available for PPL objects
defining convex and closed polyhedra. A list of the available
PPL methods for convex polyhedra for the Java interface is given in
Section \ref Java_Generated_Methods "Java Generated Methods".

<H2><CODE>
  C_Polyhedron(space_dimension, universe_or_empty)
</CODE>
</H2>
   Initializes a reference to a C polyhedron \f$\cP\f$
   with <CODE>space_dimension</CODE> dimensions; it is empty
   or the universe polyhedron depending on whether
   <CODE>universe_or_empty</CODE>
   is <CODE>empty</CODE> or <CODE>universe</CODE>, respectively.

<H2><CODE>
C_Polyhedron(c_poly)
 </CODE></H2>
   If <CODE>c_poly</CODE> refers to a C polyhedron \f$\cP_1\f$,
   then the expression will initialize a reference to a
   copy \f$\cP_2\f$ of \f$\cP_1\f$.

<H2><CODE>
C_Polyhedron(nnc_poly)
 </CODE></H2>
   If <CODE>nnc_poly</CODE> refers to the NNC polyhedron \f$\cP_1\f$,
   then the expression initializes a reference to
   a copy \f$\cP_2\f$ of \f$\cP_1\f$.

   When using this method,
   care must be taken that the source polyhedron referenced by
   <CODE>c_poly</CODE> is topologically closed.

<H2><CODE>
   C_Polyhedron(constraint_system)
 </CODE></H2>
   Initializes a reference to a C polyhedron \f$\cP\f$ represented by
   <CODE>constraint_system</CODE>.

<H2><CODE>
   C_Polyhedron(generator_system)
 </CODE></H2>
   Initializes a reference to a C polyhedron \f$\cP\f$ represented by
   <CODE>generator_system</CODE>.

<H2><CODE> space_dimension() </CODE></H2>
   Returns the dimension of the vector space in which the
   polyhedron is embedded.

<H2><CODE> affine_dimension()
</CODE></H2>
   Returns the actual dimension of the polyhedron.

<H2><CODE> get_constraints()
 </CODE></H2>
   Returns a reference to a constraint system
   representing the polyhedron referred to by \c this.

<H2><CODE> get_generators()
 </CODE></H2>
   Returns a reference to a generators system
   representing the polyhedron referred to by \c this.

<H2><CODE> relation_with_constraint(constraint)
</CODE></H2>
   Returns a reference to an instance of the Poly_Con_Relation class
   which describes the relations that the polyhedron referred to by
   \c this has with <CODE>constraint</CODE>.
   The possible relations and their meaning is given in Section
   \extref{relation_with, Relation-With Operators}
   of the main PPL user manual.

<H2><CODE> relation_with_generator(generator)
</CODE></H2>
   Returns a reference to an instance of the Poly_Gen_Relation class
   which describes the relations that the polyhedron referred to by
   \c this has with <CODE>generator</CODE>.
   The possible relations and their meaning is given in Section
   \extref{relation_with, Relation-With Operators}
   of the main PPL user manual.

<H2><CODE> is_empty() </CODE></H2>
   Returns true if the polyhedron referred to by
   \c this is empty and false, otherwise.

<H2><CODE> is_universe() </CODE></H2>
   Returns true if the polyhedron referred to by
   \c this is the universe and false, otherwise.

<H2><CODE> is_bounded() </CODE></H2>
   Returns true if the polyhedron referred to by
   \c this is bounded and false, otherwise.

<H2><CODE> contains_integer_point() </CODE></H2>
   Returns true if the polyhedron referred to by
   \c this contains at least one integer point and false,
   otherwise.

<H2><CODE> bounds_from_above(lin_expr) </CODE></H2>
   Returns true if the polyhedron referred to by
   \c this referenced by
   <CODE>c_poly</CODE>  is bounded from above by <CODE>lin_expr</CODE>
   and false, otherwise.

<H2><CODE> bounds_from_below(lin_expr) </CODE></H2>
   Returns true if the polyhedron referred to by
   \c this is bounded from below by <CODE>lin_expr</CODE>
   and false, otherwise.

<H2><CODE> maximize(lin_expr, coeff_0, coeff_1, bool)
</CODE></H2>
  Returns true if the polyhedron \f$P\f$ referred to by
   \c this is not empty
  and <CODE>lin_expr</CODE> is bounded from above in \f$P\f$ and
  false, otherwise.
  <CODE>coeff_1</CODE> is the numerator of
  the supremum value and <CODE>coeff_2</CODE> the denominator
  of the supremum value.
  If the supremum is also the maximum, <CODE>bool</CODE> is true
  and false, otherwise.

<H2><CODE>
  maximize(lin_expr, coeff_0, coeff_1, bool, generator)
 </CODE></H2>
  Returns true if the polyhedron \f$P\f$ referred to by
   \c this is not empty
  and <CODE>lin_expr</CODE> is bounded from above in \f$P\f$ and
  false, otherwise.
  <CODE>coeff_1</CODE> is the numerator of
  the supremum value and <CODE>coeff_2</CODE> the denominator
  of the supremum value.
  If the supremum is also the maximum, <CODE>bool</CODE> is true
  and false, otherwise.
  <CODE>generator</CODE> is the point or closure point where
  <CODE>lin_expr</CODE> reaches the supremum.

<H2><CODE>
  minimize(lin_expr, coeff_0, coeff_1, bool)
</CODE></H2>
  Returns true if the polyhedron \f$P\f$ referred to by
   \c this is not empty
  and <CODE>lin_expr</CODE> is bounded from below in \f$P\f$ and
  false, otherwise.
  <CODE>coeff_1</CODE> is the numerator of
  the infinum value and <CODE>coeff_2</CODE> the denominator
  of the infinum value.
  If the infinum is also the minimum, <CODE>bool</CODE> is true
  and false, otherwise.

<H2><CODE>
  minimize(lin_expr, coeff_0, coeff_1, bool, generator)
</CODE></H2>
  Returns true if the polyhedron \f$P\f$ referred to by
   \c this is not empty
  and <CODE>lin_expr</CODE> is bounded from below in \f$P\f$ and
  false, otherwise.
  <CODE>coeff_1</CODE> is the numerator of
  the infinum value and <CODE>coeff_2</CODE> the denominator
  of the infinum value.
  If the infinum is also the minimum, <CODE>bool</CODE> is true
  and false, otherwise.
  <CODE>generator</CODE> is the point or closure point where
  <CODE>lin_expr</CODE> reaches the infinum.

<H2><CODE> is_topologically_closed() </CODE></H2>
   Returns true if the polyhedron referred to by
   \c this is topologically closed and false, otherwise.

<H2><CODE> contains(c_poly)
</CODE></H2>
   Returns true if the polyhedron referenced by <CODE>c_poly</CODE>
   is included in or equal to the polyhedron referred to by
   \c this and false, otherwise.

<H2><CODE> strictly_contains(c_poly)
</CODE></H2>
   Returns true if the polyhedron referenced by <CODE>c_poly</CODE>
   is included in but not equal to the polyhedron referred to by
   \c this and false, otherwise.

<H2><CODE> is_disjoint_from(c_poly)
     </CODE></H2>
   Returns true if the polyhedron referenced by
   <CODE>c_poly</CODE>  is disjoint from the polyhedron referred to by
   \c this and false, otherwise.

<H2><CODE> equals(c_poly) </CODE></H2>
   Returns true if the polyhedron referenced by
   <CODE>c_poly</CODE>  is equal to the polyhedron referred to by
   \c this and false, otherwise.

<H2><CODE> OK() </CODE></H2>
   Returns true if the polyhedron referred to by
   \c this is well formed, i.e., if it
   satisfies all its implementation invariants and false, otherwise.
   Useful for debugging purposes.

<H2><CODE> add_constraint(constraint) </CODE></H2>
   Updates the polyhedron referred to by \c this to
   one obtained by adding
   <CODE>constraint</CODE> to its constraint system.

<H2><CODE> add_generator(generator) </CODE></H2>
   Updates the polyhedron referred to by \c this to
   one obtained by adding <CODE>generator</CODE> to its generator system.

<H2><CODE> add_constraints(constraint_system)
 </CODE></H2>
   Updates the polyhedron referred to by
   \c this referenced by <CODE>c_poly</CODE> to
   one obtained by adding to its constraint system the constraints in
   <CODE>constraint_system</CODE>.

<H2><CODE> add_generators(generator_system)
 </CODE></H2>
   Updates the polyhedron referred to by \c this to
   one obtained by adding to its generator system the generators in
   <CODE>generator_system</CODE>.

<H2><CODE> intersection_assign(c_poly)
</CODE></H2>
   Assigns to the polyhedron referred to by \c this
   its intersection with the polyhedron referenced by <CODE>c_poly</CODE>.

<H2><CODE> poly_hull_assign(c_poly) </CODE></H2>
   Assigns to the polyhedron referred to by \c this
   its poly-hull with the polyhedron referenced by <CODE>c_poly</CODE>.

<H2><CODE> poly_difference_assign(c_poly)
</CODE></H2>
   Assigns to the polyhedron referred to by \c this
   its poly-difference with the polyhedron referenced by <CODE>c_poly</CODE>.

<H2><CODE> affine_image(var, lin_expr, coefficient)
</CODE></H2>
   Transforms the polyhedron referred to by \c this
   assigning the affine expression
   <CODE>lin_expr</CODE>/<CODE>coefficient</CODE> to <CODE>var</CODE>.

<H2><CODE> affine_preimage(var, lin_expr, coefficient)
</CODE></H2>
This is the inverse transformation to that for <CODE>ppl_affine_image</CODE>.

<H2><CODE> bounded_affine_image(var, lin_expr_1, lin_expr_2, coefficient)
</CODE></H2>
   Transforms the polyhedron referred to by \c this
   assigning the image with respect to the transfer relation
   <CODE>lin_expr_1/coefficient <= var <= lin_expr_2/coefficient</CODE>.

<H2><CODE> bounded_affine_preimage(var, lin_expr_1, lin_expr_2, coefficient)
</CODE></H2>
This is the inverse transformation to that for
<CODE>ppl_bounded_affine_image</CODE>.

<H2><CODE> generalized_affine_image(var, Relation_Symbol, lin_expr,
                                    coefficient)
</CODE></H2>
   Transforms the polyhedron referred to by \c this
   assigning the generalized
   affine image with respect to the transfer function
   <CODE>var</CODE> <CODE>Relation_Symbol</CODE>
   <CODE>lin_expr</CODE>/<CODE>coefficient</CODE>.


<H2><CODE> generalized_affine_image(lin_expr_1, Relation_Symbol,
                                            lin_expr_2)
</CODE></H2>
   Transforms the polyhedron referred to by \c this
   assigning the generalized
   affine image with respect to the transfer function
   <CODE>lin_expr_1</CODE> <CODE>Relation_Symbol</CODE>
   <CODE>lin_expr_2</CODE>.

<H2><CODE> generalized_affine_preimage(lin_expr_1, Relation_Symbol,
                                       lin_expr_2)
</CODE></H2>
<H2><CODE> generalized_affine_preimage(lin_expr_1, Relation_Symbol,
                                       lin_expr_2)
</CODE></H2>
Thes are the inverse transformations to those for
<CODE>ppl_generalized_affine_image</CODE>.

<H2><CODE> time_elapse_assign(c_poly) </CODE></H2>
   Assigns to the polyhedron \f$\cP\f$ referred to by \c this
   the time-elapse \f$ (\cP \nearrow \cQ)\f$
   with the polyhedron \f$\cQ\f$ referenced by <CODE>c_poly</CODE>.

<H2><CODE> BHRZ03_widening_assign(c_poly, num_of_tokens)
</CODE></H2>
<H2><CODE> H79_widening_assign(c_poly, num_of_tokens)
</CODE></H2>
   If the polyhedron \f$\cP_1\f$ referred to by \c this
   contains the polyhedron \f$\cP_2\f$ referenced by <CODE>c_poly</CODE>,
   then \c this will refer to
   the widening of \f$\cP_1\f$ with \f$\cP_2\f$ using either
   the BHRZ03 or the H79 widening.
   It is assumed that the polyhedron \f$\cP_1\f$ referred to by \c this
   contains the polyhedron \f$\cP_2\f$ referenced by <CODE>c_poly</CODE>;
   let \f$\cP\f$ denote the BHRZ03-widening of
   \f$\cP_1\f$ with \f$\cP_2\f$.
   See Sections \extref{Widening_Operators, Widening Operators}
   and \extref{Widening_with_Tokens, Widening with tokens} in
   the main PPL user manual for more information
   on these operations and the use of the tokens.

<H2><CODE>
   limited_BHRZ03_extrapolation_assign(c_poly, constraint_system,
                                       num_of_tokens)
</CODE></H2>
<H2><CODE>
   limited_H79_extrapolation_assign(c_poly, constraint_system,
                                    num_of_tokens)
</CODE></H2>
   If the polyhedron \f$\cP_1\f$ referred to by \c this
   contains the polyhedron \f$\cP_2\f$ referenced by <CODE>c_poly</CODE>,
   then  \c this will refer to
   the extrapolation of \f$\cP_1\f$ with \f$\cP_2\f$ using either
   the BHRZ03 or the H79 widening improved by enforcing the constraints in
   <CODE>constraint_system</CODE>.
   See Sections \extref{Extrapolation_Operators, Extrapolation Operators}
   and \extref{Widening_with_Tokens, Widening with tokens} in
   the main PPL user manual for more information
   on these operations and the use of the tokens.

<H2><CODE>
   bounded_BHRZ03_extrapolation_assign(c_poly, constraint_system,
                                       num_of_tokens)
</CODE></H2>
<H2><CODE>
   bounded_H79_extrapolation_assign(c_poly, constraint_system,
                                    num_of_tokens)
</CODE></H2>
   If the polyhedron \f$\cP_1\f$ referred to by \c this
   contains the polyhedron \f$\cP_2\f$ referenced by <CODE>c_poly</CODE>,
   then  \c this will refer to
   the extrapolation of \f$\cP_1\f$ with \f$\cP_2\f$ using either
   the BHRZ03 or the H79 widening improved by enforcing the constraints in
   <CODE>constraint_system</CODE> together with all constraints of
   the form \f$\pm x \leq r\f$ and \f$\pm x < r\f$ that are satisfied
   by every point in \f$\cP_1\f$.
   See Sections \extref{Extrapolation_Operators, Extrapolation Operators}
   and \extref{Widening_with_Tokens, Widening with tokens} in
   the main PPL user manual for more information
   on these operations and the use of the tokens.

<H2><CODE> topological_closure_assign() </CODE></H2>
   Assigns to the polyhedron referred to by \c this
   its topological closure.

<H2><CODE> add_space_dimensions_and_embed(space_dimension)
 </CODE></H2>
   Embeds the polyhedron  referenced by <CODE>c_poly</CODE>
   in a space that is enlarged by <CODE>space_dimension</CODE> dimensions,

<H2><CODE> concatenate_assign(c_poly) </CODE></H2>
   Updates the polyhedron \f$\cP_1\f$ referred to by \c this
   by first embedding \f$\cP_1\f$ in a new space enlarged by
   the space dimensions
   of the polyhedron \f$\cP_2\f$ referenced by <CODE>c_poly</CODE>,
   and then adds to its system of constraints
   a renamed-apart version of the constraints of  \f$\cP_2\f$.

<H2><CODE> add_space_dimensions_and_project(space_dimension)
 </CODE></H2>

   Projects the polyhedron referred to by \c this
   onto a space that is enlarged by <CODE>space_dimension</CODE> dimensions,

<H2><CODE> remove_space_dimensions(var_set)
</CODE></H2>
   Removes the space dimensions given by the identifiers of the
   PPL variables represented by the <CODE>Variable_Set</CODE> object
   <CODE>var_set</CODE>
   from the polyhedron referred to by \c this.
   The identifiers for the remaining PPL variables are renumbered so that
   they are consecutive and the maximum index is less than the number
   of dimensions.

<H2><CODE> remove_higher_space_dimensions(space_dimension)
</CODE></H2>
   Projects the polyhedron referred to by \c this
   onto  the first <CODE>space_dimension</CODE> dimensions.

<H2><CODE>
  expand_space_dimension(var, space_dimension)
</CODE></H2>
   <CODE>space_dimension</CODE> copies of the space dimension
   represented by the <CODE>Variable</CODE> object <CODE>var</CODE>
   are added to the polyhedron referred to by \c this.

<H2><CODE>
  fold_space_dimensions(var_set, var)
</CODE></H2>
   The space dimensions represented by the <CODE>Variable_Set</CODE> object
   <CODE>var_set</CODE> are folded into the dimension referenced
   by the <CODE>Variable</CODE> object <CODE>var</CODE> and removed.
   The result is undefined if <CODE>var_set</CODE>
   does not have the properties described in Section
   \extref{fold_space_dimensions,
   Folding Multiple Dimensions of the Vector Space into One Dimension}
   of the main PPL user manual.

<H2><CODE> map_space_dimensions(p_func) </CODE></H2>
   Maps the space dimensions of the polyhedron referred to by \c this
   using the partial function defined by the <CODE>Partial_Function</CODE>
   object \p p_func.
   The result is undefined if \p p_func does not encode a partial
   function with the properties described in
   Section \extref{Mapping_the_Dimensions_of_the_Vector_Space,
   Mapping the Dimensions of the Vector Space}
   of the main PPL user manual.
