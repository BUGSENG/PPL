
Coding Standards for the Parma Polyhedra Library
================================================

Please read the first chapters of "Ada 95 Quality and Style:
Guidelines for Professional Programmers" (you will find a link to it
in the "Links" section of the PPL web site).


Names
-----

Carefully choose names that clarify the nature or the intended use of
the entity you are naming.  Do not be afraid of long identifiers, even
though conciseness is always a good thing.  Do not use abbreviations
when shorter synonyms exist.  Use underscores to separate words in a
compound name.  By all means, avoid baStudlyCaps: write
available_widening_tokens (if it is a variable) or
Available_Widening_Tokens (if it is a class or enum); never write
availableWideningTokens or AvailableWideningTokens.


Pre and post increment and decrement operators
----------------------------------------------

All other things being equal, always prefer preincrement and
predecrement to postincrement and postdecrement.


Swap specialization
-------------------

All library types should provide a publicly available swap method.
Whenever appropriate for ensuring efficiency, the generic std::swap
algorithm should be specialized to use the swap method.


Limiting the visibility of variables and functions
--------------------------------------------------

Avoid using the keyword "static" to specify that global variables or
functions should be visible only inside the current translation unit;
use the anonymous namespace, instead. The keyword "static" should
only appear inside class definitions or function bodies. As an example,

static const char* s = "Not accessible by other translation units";

static void f() {
  // ... function body ...
}

should be replaced by

namespace {

const char* s = "Not accessible by other translation units";

void f() {
  // ... function body ...
}

} // namespace


Length of source lines
----------------------

Avoid, when possible, source lines longer than 78 characters.


Block closures
--------------

Try to make clear what is being closed.  For example:

1)

namespace Parma_Polyhedra_Library {

...

} // namespace Parma_Polyhedra_Library

2)

extern "C" {

...

} // extern "C"

3)

#ifndef PPL_Class_defs_hh

...

#endif // !defined(PPL_Class_defs_hh)


Namespace indentation
---------------------

The entire library is in its own namespace.  We sometimes specialize
std::swap() and std::iter_swap().  Other namespaces may be involved
but only in restricted contexts.  Therefore, we have unindented
namespace-level declarations, thus saving some precious horizontal
space.  For example:

namespace Parma_Polyhedra_Library {

non-empty lines here start at column 0;

} // namespace Parma_Polyhedra_Library

If you use emacs, you may want to put the following two lines in your
.emacs:

;; Disable indentation when in namespace blocks.
(c-set-offset 'innamespace 0)


Negation
--------

Use `!' to negate a value.

For example, use

	if (!ph.is_empty())
	   std::cout << "ph contains at least one point" << endl;

instead of

	if (ph.is_empty() == false)
	   std::cout << "ph contains at least one point" << endl;


Comparison with zero
--------------------

Be explicit when comparing a value with zero in a conditional context.

For example, use

	assert(sys.num_rows() != 0);

instead of

	assert(sys.num_rows());


Macros
------

Macros should be used only if really needed (in many cases, macros can
be replaced by inline functions).

If macros are used, their scope should be minimized as much as possible.
In particular, all macros that are not meant to be directly accessible
by the user should be #undef'ed as soon as possible in the source file
they are defined in.

Macros should be given conspicuous names starting with "PPL_".


Standards for Structuring the Source Code in Files
==================================================

Source code should be organized so as to ensure that:
  - the contents of a file are strongly related;
  - each file is of manageable size.

As a rule of thumb, each type (class, struct, class template, etc.)
named "Xtype" that is relevant on its own for the user or the
developer of the library should be provided with a set of source files
whose filenames start with "Xtype". The source files for such a type
should be named and populated as follows:

a) Xtype.types.hh
Contains the forward declarations of type names (in particular, the
one for "Xtype") and other useful typedef's.

b) Xtype.defs.hh
Contains the definition of the type, togheter with the declaration of
any function that, even though not being formally part of the type, is
nonetheless related to it and should therefore be considered part of
its interface.

c) Xtype.inlines.hh
Contains the definitions of inline functions.
Temporarily, also contains the non-inline definitions of all class
template members and all (member or non-member) function templates
that are not fully specialized. Eventually, these will be systematically
moved in other files called Xtype.templates.hh.

d) Xtype.cc
Contains the definitions of non-inline functions, including non-inline
full specializations of templates;

e) When appropriate, further *.cc files can be used to split huge
source files into more manageable components (e.g., see the files
Polyhedron_public.cc, Polyhedron_nonpublic.cc, Polyhedron_chdims.cc
and Polyhedron_widenings.cc, or even conversion.cc, minimize.cc, etc.).

Note that:
  - all interface functions should be declared in Xtype.defs.hh;
  - no function definition should be placed in Xtype.defs.hh;
  - bare declarations should not be declared inline (i.e., inline directives
    should be placed only in front of the definition of the functions);
  - inner classes are usually kept in the same files as the outer class;
  - functions having the anonymous namespace scope can be (and usually are)
    only declared and defined in file Xtype.cc, regardless of whether or not
    the inline directive is specified.


Standards for Documenting the Project with Doxygen
==================================================

1) All code entities (classes, structs, enums, variables, methods,
   functions, etc.) should be provided with a brief Doxygen comment.
   Brief comments are normally obtained as follows:

     //! Brief comment for class C.
     class C {
       ...
     };

   If the comment is multi-line, then either of the following
   syntax can be adopted:

     //! \brief
     //! A brief comment for class C, that is a bit too long
     //! to be placed in a single line.
     class C {
       ...
     };

  or

     /*! \brief
         A brief comment for class C, that is a bit too long
         to be placed in a single line.
     */
     class C {
       ...
     };

2) A *friend* declaration of a function should NOT be provided with
   a Doxygen comment. Rather, it is the very declaration of the function
   (which should be found outside of the class) that has to be documented.

3) When needed or useful, brief comments should be followed
   by detailed Doxygen comments.

     //! Brief comment for class C.
     /*!
	More details on class C.
	Even more details.
     */
     class C {
       ...
     };

   In the produced documentation, the brief comment will be
   automatically repeated just before the detailed comment,
   so that bare repetitions should be avoided.

4) In the source files, detailed comments should be placed
   immediately after the brief ones, so that all the documentation
   pertinent to a code entity is kept in a single file
   (typically, the *.defs.hh file).

5) It is also possible to merge the brief and detailed comments inside
   a single (detailed) Doxygen documentation block, as follows:

     /*!
        \brief
        Brief comment for class C.

	More details on class C.
	Even more details.
     */
     class C {
       ...
     };

   The first paragraph break (in this case, the empty line) marks the
   separation between the brief and the detailed part. Note that
   all the uses of \param, \result and \exception special commands
   will automatically cause a paragraph break, therefore starting
   the detailed part. This will happen even when using the //! style
   documentation blocks and the \brief command.

6) Brief Doxygen comments should be brief (indeed).
   If more than two lines are required, then the comment should be
   split into a brief part and a detailed part.

7) Code entities or details that should not be visible to the end-user
   (but that are useful for the developers) should be surrounded by

     #ifdef PPL_DOXYGEN_INCLUDE_IMPLEMENTATION_DETAILS
	//! ... doxygen comments ...
     #endif // PPL_DOXYGEN_INCLUDE_IMPLEMENTATION_DETAILS

   so that they will only appear in the developer's reference.
   Note that the above preprocessing flags are not necessary
   (and should therefore be avoided) when documenting:
    - a private member of a class (because private members never
      appear in the user manual);
    - a public member of a class that is not documented
      (because even the documented members of an undocumented
      class are automatically filtered out of the user manual).

8) Merging multiple comment blocks is not allowed by Doxygen.
   Thus, the technique described in point 4) above is useless
   when we want an end-user comment block to be integrated,
   in the developer's reference only, by further comments.
   In such a case, a single comment block should be used as follows:

     // ... doxygen comments for both user and developer ...
     // \if Include_Implementation_Details
     // ... doxygen comments for developer only ...
     // \endif
     // ... doxygen comments for both user and developer ...

9) The documentation of those functions that are neither methods
   nor friends of a given class, but are related in some way to that
   class, should be made part of the documentation of the class.
   This is obtained by using the Doxygen \relates special command
   as follows:

     /*! \relates Classname */

   It seems that, in order to correctly match function declarations
   and definitions, the above command should be placed in both places.
   Typically, this will be the only kind of Doxygen command
   occurring in *.inlines.hh and *.cc source files.

   If Classname is a templatic class, the arguments of the template
   (as well as the angle brackets) should be omitted.
   The namespace qualification of the class can be omitted, provided
   the comment block is included in the namespace scope.

10)
  If the \return or \param special commands are used, then these have to
  be placed after the brief doxygen comment.  The \return special
  command, if present, should come before any \param command.  The
  \exception special command, if present, should come after any \param
  command. All the parameters of the function should be provided by the
  corresponding \param command, respecting their textual order,
  separating them with a blank line.  The documentation of each
  parameter should start at the line immediately following the \param
  command.  Typically, the list of parameters should be formatted as
  follows, where the \return command is optional.

  /*! \brief
    The brief description.

    The detailed description, if any.

    \return
    Documentation for the return value, if provided.

    \param p1
    Documentation for p1;

    \param p2
    Documentation for p2;
    other documentation for p2;

    \param p3
    Documentation for p3.

    \exception exception_type1
    Documentation for the exceptions of type exception_type1;

    \exception exception_type2
    Documentation for the exceptions of type exception_type2.

    Another piece of detailed description, if needed.
  */
  int foo(const bar& p1, const bar& p2, int p3);

